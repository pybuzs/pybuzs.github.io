<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySql进阶 | 片叶不沾身的花园</title><meta name="author" content="bbiao"><meta name="copyright" content="bbiao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySql进阶 此笔记由本人学习 B 站黑马程序员 MySQL 数据库视频进阶篇内容后，总结提取摘要制成。视频地址：黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括  MySQL体系结构MySQL体系结构：连接层，服务层，引擎层，存储层。   连接层：处理客户端连接、认证和线程管理。 连接器（Connector）： 处理客户端连接请求，支持 TCP&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="MySql进阶">
<meta property="og:url" content="https://pybuzs.github.io/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="片叶不沾身的花园">
<meta property="og:description" content="MySql进阶 此笔记由本人学习 B 站黑马程序员 MySQL 数据库视频进阶篇内容后，总结提取摘要制成。视频地址：黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括  MySQL体系结构MySQL体系结构：连接层，服务层，引擎层，存储层。   连接层：处理客户端连接、认证和线程管理。 连接器（Connector）： 处理客户端连接请求，支持 TCP&amp;#">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pybuzs.github.io/image/touxiang.jpg">
<meta property="article:published_time" content="2025-06-10T03:31:31.000Z">
<meta property="article:modified_time" content="2025-06-24T03:25:14.134Z">
<meta property="article:author" content="bbiao">
<meta property="article:tag" content="MySql进阶 学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pybuzs.github.io/image/touxiang.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySql进阶",
  "url": "https://pybuzs.github.io/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/",
  "image": "https://pybuzs.github.io/image/touxiang.jpg",
  "datePublished": "2025-06-10T03:31:31.000Z",
  "dateModified": "2025-06-24T03:25:14.134Z",
  "author": [
    {
      "@type": "Person",
      "name": "bbiao",
      "url": "https://pybuzs.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/%E5%8D%A1%E9%80%9A%E8%80%81%E8%99%8E.png"><link rel="canonical" href="https://pybuzs.github.io/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySql进阶',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="/styles/jquery.min.js"></script><script src="/styles/raindrop.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/image/beijing.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">片叶不沾身的花园</span></a><a class="nav-page-title" href="/"><span class="site-name">MySql进阶</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MySql进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-10T03:31:31.000Z" title="发表于 2025-06-10 11:31:31">2025-06-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-24T03:25:14.134Z" title="更新于 2025-06-24 11:25:14">2025-06-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySql/">MySql</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySql/MySql%E8%BF%9B%E9%98%B6/">MySql进阶</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="MySql进阶"><a href="#MySql进阶" class="headerlink" title="MySql进阶"></a>MySql进阶</h1><blockquote>
<p>此笔记由本人学习 B 站黑马程序员 MySQL 数据库视频进阶篇内容后，总结提取摘要制成。<br>视频地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru/?share_source=copy_web&vd_source=e43c1de8e41e1499f7f3fdb03fba0eb6">黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括</a></p>
</blockquote>
<h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><p>MySQL体系结构：连接层，服务层，引擎层，存储层。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/2025-06-10115712.png" alt="2025-06-10115712"></p>
<ol>
<li>连接层：处理客户端连接、认证和线程管理。<ul>
<li><strong>连接器（Connector）</strong>：<ul>
<li>处理客户端连接请求，支持 TCP&#x2F;IP、Unix Socket、命名管道等连接方式。</li>
<li>验证用户身份（用户名、密码、主机权限）。</li>
<li>为每个连接分配线程（或从线程池获取）。</li>
</ul>
</li>
<li><strong>线程池（Thread Pool）</strong>：<ul>
<li>管理数据库连接线程，减少频繁创建 &#x2F; 销毁线程的开销。</li>
<li>适用于高并发场景（如 MySQL Enterprise Edition）。</li>
</ul>
</li>
</ul>
</li>
<li>服务层：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。<ul>
<li><strong>SQL 接口（SQL Interface）</strong>：<ul>
<li>接收 SQL 请求（SELECT、INSERT 等），返回查询结果。</li>
</ul>
</li>
<li><strong>查询解析器（Parser）</strong>：<ul>
<li>对 SQL 语句进行词法和语法分析，生成解析树（Parse Tree）。</li>
<li>验证语句语法正确性（如关键字拼写、表名 &#x2F; 列名是否存在）。</li>
</ul>
</li>
<li><strong>预处理器（Preprocessor）</strong>：<ul>
<li>进一步检查解析树的合法性（如权限检查、外键约束验证）。</li>
<li>替换别名、展开视图等操作。</li>
</ul>
</li>
<li><strong>查询优化器（Optimizer）</strong>：<ul>
<li>生成最优执行计划（如选择索引、表连接顺序）。</li>
<li>支持成本优化（Cost-Based Optimization, CBO）和规则优化（Rule-Based Optimization, RBO）。</li>
</ul>
</li>
<li><strong>查询执行引擎（Execution Engine）</strong>：<ul>
<li>根据执行计划调用存储引擎 API 执行查询。</li>
</ul>
</li>
<li><strong>缓存（Query Cache）</strong>：<ul>
<li>缓存 SQL 语句及其结果（5.7 版本后逐渐弃用，8.0 版本移除）。</li>
<li>当数据发生变更时，相关缓存会被自动清除。</li>
</ul>
</li>
</ul>
</li>
<li>引擎层：负责数据的存储和检索。架构模式是插件式，服务器通过API和存储引擎进行通信。支持 InnoDB、MyISAM、Memory 等多个存储引擎。<ul>
<li><strong>插件式架构</strong>：支持多种存储引擎，通过统一接口与上层交互。</li>
<li>常见引擎：<ul>
<li><strong>InnoDB</strong>：默认引擎，支持事务、外键、行级锁。</li>
<li><strong>MyISAM</strong>：不支持事务，表级锁，适合读多写少场景。</li>
<li><strong>Memory</strong>：数据存储在内存，读写极快，重启丢失数据。</li>
<li><strong>Archive</strong>：高度压缩，仅支持 INSERT&#x2F;SELECT，适合历史数据归档。</li>
</ul>
</li>
<li>核心功能：<ul>
<li>数据存储与检索（如 B + 树索引、哈希索引）。</li>
<li>事务处理（InnoDB）。</li>
<li>锁机制（行锁、表锁）。</li>
</ul>
</li>
</ul>
</li>
<li>存储层：MYSQL的物理存储部分，负责将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在磁盘上。<ul>
<li><strong>数据文件</strong>：<ul>
<li><strong>.frm</strong>：存储表结构定义。</li>
<li><strong>.ibd</strong>：InnoDB 独立表空间文件（存储数据和索引）。</li>
<li><strong>.MYD&#x2F;.MYI</strong>：MyISAM 数据文件和索引文件。</li>
</ul>
</li>
<li><strong>日志文件</strong>：<ul>
<li><strong>二进制日志（Binlog）</strong>：记录数据变更，用于主从复制和恢复。</li>
<li><strong>重做日志（Redo Log）</strong>：确保事务持久性，崩溃恢复。</li>
<li><strong>回滚日志（Undo Log）</strong>：支持事务回滚和 MVCC。</li>
<li><strong>错误日志（Error Log）</strong>：记录启动、运行时错误信息。</li>
<li><strong>慢查询日志（Slow Query Log）</strong>：记录执行时间超过阈值的 SQL。</li>
</ul>
</li>
<li><strong>配置文件</strong>：<ul>
<li><strong>my.cnf&#x2F;my.ini</strong>：存储 MySQL 配置参数（如内存分配、字符集）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>他是mysql数据库的核心，我们也需要在合适的场景选择合适的存储引擎。存储引擎是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式 。存储引擎是基于表的，而不是 基于库的，所以存储引擎也可被称为表类型。可以在创建表的时指定选择的存储引擎，没有指定将自动选择默认的存储引擎。</p>
<ul>
<li>建表时指定存储引擎</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型 [ COMMENT 字段<span class="number">1</span>注释 ] ,</span><br><span class="line">......</span><br><span class="line">字段n 字段n类型 [COMMENT 字段n注释 ]</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB [ COMMENT 表注释 ] ;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询当前数据库支持的存储引擎</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure>

<p>MySQL 支持多种存储引擎，每种引擎都有其独特的特性和适用场景。以下是常见存储引擎的对比及选择建议。</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>DML操作遵循ACID模型，支持事务；</li>
<li>行级锁，提高并发访问性能；</li>
<li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</li>
</ul>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><ul>
<li><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。</p>
</li>
<li><p>参数：innodb_file_per_table</p>
</li>
</ul>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/2025-06-10163404.png" alt="2025-06-10163404"></p>
<p>  如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。ibd文件中不仅存放表结构、数据还会存放该表对应的索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。</p>
<h4 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h4><p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/2025-06-10164034.png" alt="2025-06-10164034"></p>
<ul>
<li>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以<br>包含多个Segment段。</li>
<li>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管<br>理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</li>
<li>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为<br>16K， 即一个区中一共有64个连续的页。</li>
<li>页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默<br>认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li>
<li>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时<br>所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>事务性应用（如电商、金融系统）。</li>
<li>高并发读写场景。</li>
<li>需要外键约束的表。</li>
</ul>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>MyISAM是MySQL早期的默认存储引擎。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁，不支持行锁</li>
<li>优点：更少的存储空间，支持全文索引，适用于读取频率较高、写入频率较低的应用场景</li>
</ul>
<h4 id="文件结构-1"><a href="#文件结构-1" class="headerlink" title="文件结构"></a>文件结构</h4><ul>
<li><p>xxx.sdi：存储表结构信息</p>
</li>
<li><p>xxx.MYD: 存储数据</p>
</li>
<li><p>xxx.MYI: 存储索引</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/2025-06-10165422.png" alt="2025-06-10165422"></p>
</li>
</ul>
<h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>只读或写入少、查询多的场景（如日志表、统计数据）。</li>
<li>不需要事务支持的场景。</li>
</ul>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>数据存储在内存</strong>：读写速度极快，但重启后数据丢失。</li>
<li><strong>支持哈希索引</strong>：适合快速查找。</li>
<li><strong>表级锁</strong>：并发性能有限。</li>
</ul>
<h4 id="文件结构-2"><a href="#文件结构-2" class="headerlink" title="文件结构"></a>文件结构</h4><ul>
<li>xxx.sdi：存储<strong>表结构信息</strong></li>
<li>数据， 都在内存中</li>
</ul>
<h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li><strong>临时表&#x2F;中间结果集：</strong> MySQL 内部自动使用。</li>
<li><strong>高速缓存：</strong> 存储频繁访问的小型、非关键、可丢失的只读&#x2F;低频写数据（如会话信息、配置）。</li>
<li>需要极低延迟访问的<strong>只读查询</strong>。</li>
</ul>
<p>重要警告： 绝对不要用于存储重要或持久化数据。内存有限，大表易导致 OOM。</p>
<h3 id="InnoDB-MyISAM-Memory的区别，使用场景"><a href="#InnoDB-MyISAM-Memory的区别，使用场景" class="headerlink" title="InnoDB, MyISAM, Memory的区别，使用场景"></a>InnoDB, MyISAM, Memory的区别，使用场景</h3><p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/0fb3844e83912d08779b1b8a1ab51f24.png" alt="0fb3844e83912d08779b1b8a1ab51f24"></p>
<blockquote>
<p>面试题:<br>InnoDB引擎与MyISAM引擎的区别 ?<br>①. InnoDB引擎, 支持事务, 而MyISAM不支持。<br>②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。<br>③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。它类似于书籍的目录，允许数据库快速定位特定数据，避免全表扫描。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/40c81bd2db81dab60339a59238cbf784.png" alt="40c81bd2db81dab60339a59238cbf784"></p>
<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><table>
<thead>
<tr>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody><tr>
<td>提高数据检索的效率，降低数据库 的IO成本</td>
<td>索引列也是要占用空间的。</td>
</tr>
<tr>
<td>通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消耗。</td>
<td>索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT、UPDATE、DELETE时，效率降低。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/2025-06-10174544.png" alt="2025-06-10174544"></p>
<p>上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持 情况。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/2025-06-10174544.png" alt="2025-06-10174544"></p>
<blockquote>
<p>注意： 我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</p>
</blockquote>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611113621344.png" alt="image-20250611113621344"></p>
<p>如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611113655369.png" alt="image-20250611113655369"></p>
<p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p>
<ul>
<li>顺序插入时，会形成一个链表，查询性能大大降低。</li>
<li>大数据量情况下，层级较深，检索速度慢。</li>
</ul>
<p>此时大家可能会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数 据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611114007240.png" alt="image-20250611114007240"></p>
<p>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</p>
<ul>
<li>解决二叉树的顺序插入后，树不平衡的问题。</li>
<li>大数据量情况下，层级较深，检索速度慢。</li>
</ul>
<h4 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h4><p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。 以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针：</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611115454645.png" alt="image-20250611115454645"></p>
<blockquote>
<p>知识小贴士: 树的度数指的是一个节点的子节点个数。</p>
</blockquote>
<p>我们可以通过一个数据结构可视化的网站来简单演示一下。<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">B-Tree Visualization (usfca.edu)</a></p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611120126681.png" alt="image-20250611120126681"></p>
<p>插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611121752144.png" alt="image-20250611121752144"></p>
<p>特点：</p>
<ul>
<li>5阶的B树，每一个节点最多存储4个key，对应5个指针。</li>
<li>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</li>
<li>在B树中，非叶子节点和叶子节点都会存放数据。</li>
</ul>
<h4 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h4><p>B+Tree是B-Tree的变种，我们以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一 下其结构示意图：</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611122001256.png" alt="image-20250611122001256"></p>
<p>我们可以看到，两部分： </p>
<ul>
<li>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。 </li>
<li>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</li>
</ul>
<p>通过一个数据结构可视化的网站来简单演示一下。[<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">B+ Tree Visualization (usfca.edu)</a></p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611122833474.png" alt="image-20250611122833474"></p>
<p>插入一组数据： 100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250 。然后观察一些数据插入过程中，节点的变化情况。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611173955579.png" alt="image-20250611173955579"></p>
<p>最终我们看到，B+Tree 与 B-Tree相比，主要有以下三点区别： </p>
<ul>
<li>所有的数据都会出现在叶子节点。 </li>
<li>叶子节点形成一个单向链表。</li>
<li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li>
</ul>
<p><strong>MySQL优化后的B+ Tree：</strong></p>
<p>上述我们所看到的结构是标准的B+Tree的数据结构，接下来，我们再来看看MySQL中优化之后的 B+Tree。 MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611174229224.png" alt="image-20250611174229224"></p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在<br>hash表中。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611174846421.png" alt="image-20250611174846421"></p>
<p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可 以通过链表来解决。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611174905670.png" alt="image-20250611174905670"></p>
<p>特点：</p>
<ul>
<li>Hash索引只能用于对等比较(&#x3D;，in)，不支持范围查询（between，&gt;，&lt; ，…）。</li>
<li>无法利用索引完成排序操作。</li>
<li>查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引。</li>
</ul>
<p>在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p>
<blockquote>
<p><strong>为什么 InnoDB 存储引擎选择使用 B+tree 索引结构?</strong></p>
<ul>
<li><strong>相对于二叉树，层级更少，搜索效率高；</strong></li>
<li><strong>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储 的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</strong></li>
<li><strong>相对Hash索引，B+tree支持范围匹配及排序操作；</strong></li>
</ul>
</blockquote>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611175344688.png" alt="image-20250611175344688"></p>
<p>而在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611175501825.png" alt="image-20250611175501825"></p>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引。 </li>
<li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li>
<li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li>
</ul>
<p>聚集索引和二级索引的具体结构如下：</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611180444425.png" alt="image-20250611180444425"></p>
<ul>
<li>聚集索引的叶子节点下挂的是这一行的数据 。</li>
<li>二级索引的叶子节点下挂的是该字段值对应的主键值。</li>
</ul>
<h4 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a><strong>回表查询</strong></h4><p>先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。</p>
<p>当我们执行如下的SQL语句时，具体的查找过程是什么样子的。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250611180640456.png" alt="image-20250611180640456"></p>
<p>具体过程如下:</p>
<p>①. 由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查 找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</p>
<p>②. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最 终找到10对应的行row。</p>
<p>③. 最终拿到这一行的数据，直接返回即可。</p>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ol>
<li>以下两条SQL语句，那个执行效率高? 为什么?</li>
</ol>
<p>​	A. select * from user where id &#x3D; 10 ;<br>​	B. select * from user where name &#x3D; ‘Arm’ ; 备注: id为主键，name字段创建的有索引；</p>
<p>解答： A 语句的执行性能要高于B 语句。 因为A语句直接走聚集索引，直接返回数据。 而B语句需要先查询name字段的二级索引，然 后再查询聚集索引，也就是需要进行回表查询。</p>
<ol start="2">
<li>InnoDB主键索引的B+tree高度为多高呢?</li>
</ol>
<p>假设: 一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空 间，主键即使为bigint，占用字节数为8。 </p>
<p><strong>关键公式</strong>：<br>每个非叶子节点的索引条目数 n 需满足：n × 主键大小 + (n + 1) × 指针大小 ≤ 页大小。</p>
<ul>
<li><code>n × 8</code> ：n 个主键值的总字节数；</li>
<li><code>(n + 1) × 6</code> ：n+1 个指针的总字节数（每个节点至少有 n+1 个指针指向子节点）。</li>
<li>算出n约为 1170，也就是说每个非叶子节点最多存储 1170 个索引条目，对应 1171 个子节点（n+1）。</li>
</ul>
<p>B + 树高度为 2 时的最大数据量：</p>
<ul>
<li><strong>树结构</strong>：非叶子节点（根节点）+ 叶子节点。</li>
<li><strong>叶子节点数量</strong>：根节点的子节点数 &#x3D; 1171 个。</li>
<li><strong>每个叶子节点存储数据量</strong>：16 行（由页大小决定）。</li>
<li><strong>总数据量</strong>：<code>1170 × 16 = 18,720条</code>。可以存储 18000 多条记录。</li>
</ul>
<p>B + 树高度为 3 时的最大数据量：</p>
<ul>
<li><strong>树结构</strong>：根节点 + 中间层 + 叶子层。</li>
<li><strong>叶子节点数量</strong>：根节点的子节点数 &#x3D; 1171 个。</li>
<li><strong>每个叶子节点存储数据量</strong>：16 行（由页大小决定）。</li>
<li><strong>总数据量</strong>：<code>1170 × 1170 × 16 = 21,902,400条</code>。可以存储 <strong>2190</strong>w 多条记录。</li>
</ul>
<h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><ol>
<li>创建索引</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT ] INDEX index_name <span class="keyword">ON</span> table_name (index_col_name,... ) ;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看索引</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name ;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除索引</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name ;</span><br></pre></td></tr></table></figure>

<h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><h4 id="SQL执行频率"><a href="#SQL执行频率" class="headerlink" title="SQL执行频率"></a>SQL执行频率</h4><p>MySQL 客户端连接成功后，通过 <code>show [session|global] status</code> 命令可以提供服务器状态信 息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p>
<blockquote>
<p>– session 是查看当前会话 ; </p>
<p>– global 是查询全局数据 ; </p>
<p>SHOW GLOBAL STATUS LIKE ‘Com_______’</p>
</blockquote>
<p>通过查询SQL的执行频次，我们就能够知道当前数据库到底是增删改为主，还是查询为主。 那假 如说是以查询为主，我们又该如何定位针对于那些查询语句进行优化呢？ 次数我们可以借助于慢查询 日志。</p>
<h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志。</p>
<p>MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。（默认是关闭的）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果要开启慢查询日志，需要在MySQL的配置文件中配置如下信息：</p>
<blockquote>
<p>Windows 下通常位于 MySQL 安装目录或 <code>C:\ProgramData\MySQL\MySQL Server X.Y</code>。</p>
<p>Linux 下（&#x2F;etc&#x2F;my.cnf）。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 启用慢查询日志</span><br><span class="line">slow_query_log <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 指定慢查询日志文件路径</span><br><span class="line">slow_query_log_file <span class="operator">=</span> &quot;C:/ProgramData/MySQL/MySQL Server 8.0/slow_query.log&quot;</span><br><span class="line"></span><br><span class="line"># 设置慢查询阈值（单位：秒）</span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"># 可选：记录未使用索引的查询</span><br><span class="line"># log_queries_not_using_indexes <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 可选：记录管理语句（如 OPTIMIZE <span class="keyword">TABLE</span>）</span><br><span class="line"># log_slow_admin_statements <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>重启MySQL 服务，然后，再次查看开关情况，慢查询日志就已经打开了。</p>
<p>测试：</p>
<ul>
<li><p>执行如下SQL语句 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SLEEP(<span class="number">11</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开慢日志文件，检查慢查询日志 ：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> Time: 2025-06-16T08:26:30.451314Z</span><br><span class="line"><span class="params">#</span> User@Host: root[root] @ localhost [::1]  Id:     4</span><br><span class="line"><span class="params">#</span> Query<span class="built_in">_</span>time: 11.007434  Lock<span class="built_in">_</span>time: 0.000000 Rows<span class="built_in">_</span>sent: 1  Rows<span class="built_in">_</span>examined: 0</span><br><span class="line">use huanyuan2;</span><br><span class="line">SET timestamp=1750062390;</span><br><span class="line">SELECT SLEEP(11);</span><br></pre></td></tr></table></figure>

<p>那这样，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化。</p>
</li>
</ul>
<h4 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h4><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p>
<ul>
<li><p>通过have_profiling 参数，能够看到当前MySQL是否支持profile操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@have_profiling</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250616170607482.png" alt="image-20250616170607482"></p>
</li>
<li><p>查看当前数据库是否打开了 profiling ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250616170818001.png" alt="image-20250616170818001"></p>
</li>
</ul>
<p>可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在 <code>session/global</code>级别开启profiling：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>profile 开关打开后，我们所执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去 了。</p>
<p>可以通过如下指令查看指令的执行耗时：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看每一条SQL的耗时基本情况</span></span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看指定query_id的SQL语句CPU的使用情况</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure>

<h4 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h4><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接在select语句之前加上关键字 explain / desc</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 ;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250616172028438.png" alt="image-20250616172028438"></p>
<p>Explain 执行计划中各个字段的含义:</p>
<table>
<thead>
<tr>
<th>字段</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td align="left">select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td>
</tr>
<tr>
<td>select_type</td>
<td align="left">表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</td>
</tr>
<tr>
<td>type</td>
<td align="left">表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。</td>
</tr>
<tr>
<td>possible_key</td>
<td align="left">显示可能应用在这张表上的索引，一个或多个。</td>
</tr>
<tr>
<td>key</td>
<td align="left">实际使用的索引，如果为NULL，则没有使用索引。</td>
</tr>
<tr>
<td>key_len</td>
<td align="left">表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。</td>
</tr>
<tr>
<td>rows</td>
<td align="left">MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。</td>
</tr>
<tr>
<td>filtered</td>
<td align="left">表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td>
</tr>
</tbody></table>
<h3 id="索引使用优化"><a href="#索引使用优化" class="headerlink" title="索引使用优化"></a>索引使用优化</h3><h4 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h4><p>单列索引：即一个索引只包含单个列。</p>
<p>联合索引：即一个索引包含了多个列。</p>
<p>我们先来看看 tb_user 表中目前的索引情况:</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250617000225325.png" alt="image-20250617000225325"></p>
<p>在查询出来的索引中，既有单列索引，又有联合索引。</p>
<p>接下来，我们来执行一条SQL语句，看看其执行计划：</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250617000312093.png" alt="image-20250617000312093"></p>
<p>通过上述执行计划我们可以看出来，在and连接的两个字段 phone、name上都是有单列索引的，但是最终mysql只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。</p>
<p>接着，我们再来创建一个phone和name字段的联合索引来查询一下执行计划。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_phone_name <span class="keyword">on</span> tb_user(phone,name);</span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250617000440235.png" alt="image-20250617000440235"></p>
<p>此时，查询时，就走了联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对 应的主键id，所以查询是无需回表查询的。</p>
<blockquote>
<p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。</p>
</blockquote>
<style>.cnjunexevqdn{zoom:67%;}</style><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250617000533014.png" class="cnjunexevqdn" alt="image-20250617000533014">

<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<ul>
<li><p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_xxxx <span class="keyword">on</span> table_name(<span class="keyword">column</span>(n)) ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>前缀长度</p>
<p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询使用email整个字符串的索引选择比   <span class="number">1.0000</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br><span class="line"># 查询使用email 使用前缀<span class="number">5</span>个字符串的索引选择比  <span class="number">0.9583</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user ;</span><br><span class="line"># 查询使用email 使用前缀<span class="number">2</span>个字符串的索引选择比   <span class="number">0.9167</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">2</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user ;</span><br><span class="line"># 对字段email建立前缀索引，前缀长度为<span class="number">5</span>  </span><br><span class="line"><span class="keyword">create</span> index email_idx <span class="keyword">on</span> tb_user(email(<span class="number">5</span>));</span><br><span class="line"># 查看使用email前缀索引进行查询的执行结构</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> email <span class="operator">=</span> <span class="string">&#x27;xiaoyu666@qq.com&#x27;</span>; </span><br></pre></td></tr></table></figure>
</li>
<li><p>前缀索引的查询流程</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250616175247635.png" alt="image-20250616175247635"></p>
</li>
</ul>
<h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是<strong>查询条件必须从复合索引的最左列开始，并且不能跳过中间列</strong>。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</p>
<h5 id="🧩-四种典型使用场景分析"><a href="#🧩-四种典型使用场景分析" class="headerlink" title="🧩 四种典型使用场景分析"></a>🧩 四种典型使用场景分析</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_age_city <span class="keyword">ON</span> users (</span><br><span class="line">    last_name,  <span class="comment">-- 最左列</span></span><br><span class="line">    age,        <span class="comment">-- 中间列</span></span><br><span class="line">    city        <span class="comment">-- 最右列</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h6 id="✅-场景-1：完整使用索引-最佳"><a href="#✅-场景-1：完整使用索引-最佳" class="headerlink" title="✅ 场景 1：完整使用索引 (最佳)"></a>✅ 场景 1：完整使用索引 (最佳)</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span> </span><br><span class="line">  <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">30</span> </span><br><span class="line">  <span class="keyword">AND</span> city <span class="operator">=</span> <span class="string">&#x27;New York&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>索引使用</strong>：<br><code>(last_name, age, city)</code> 三列全使用<br>👉 <strong>查询效率最高</strong></p>
<h6 id="✅-场景-2：使用最左连续列"><a href="#✅-场景-2：使用最左连续列" class="headerlink" title="✅ 场景 2：使用最左连续列"></a>✅ 场景 2：使用最左连续列</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span> </span><br><span class="line">  <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<p><strong>索引使用</strong>：<br><code>(last_name, age)</code> 两列<br>👉 <strong>有效使用索引</strong></p>
<h6 id="✅-场景-3：仅使用最左列"><a href="#✅-场景-3：仅使用最左列" class="headerlink" title="✅ 场景 3：仅使用最左列"></a>✅ 场景 3：仅使用最左列</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>索引使用</strong>：<br><code>(last_name)</code> 单列<br>👉 <strong>有效但非最优</strong></p>
<h6 id="❌-场景-4：违反最左前缀（常见错误）"><a href="#❌-场景-4：违反最左前缀（常见错误）" class="headerlink" title="❌ 场景 4：违反最左前缀（常见错误）"></a>❌ 场景 4：违反最左前缀（常见错误）</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误1：跳过最左列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 错误2：缺少中间列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span> </span><br><span class="line">  <span class="keyword">AND</span> city <span class="operator">=</span> <span class="string">&#x27;New York&#x27;</span>; <span class="comment">-- 跳过age列</span></span><br></pre></td></tr></table></figure>

<p><strong>索引使用</strong>：<br>无法使用索引或仅部分使用<br>👉 <strong>全表扫描风险</strong></p>
<h6 id="✅-场景-5：条件编写的先后顺序"><a href="#✅-场景-5：条件编写的先后顺序" class="headerlink" title="✅ 场景 5：条件编写的先后顺序"></a>✅ 场景 5：条件编写的先后顺序</h6><p>以下代码索引会失效吗？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span>  age <span class="operator">=</span> <span class="number">30</span></span><br><span class="line">  <span class="keyword">AND</span>  city <span class="operator">=</span> <span class="string">&#x27;New York&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span>  last_name <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>答案：不会，MySQL 优化器会自动重排条件顺序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 优化器重写后的等效查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span>  <span class="comment">-- 最左列</span></span><br><span class="line">  <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">30</span>            <span class="comment">-- 第二列</span></span><br><span class="line">  <span class="keyword">AND</span> city <span class="operator">=</span> <span class="string">&#x27;New York&#x27;</span>;  <span class="comment">-- 第三列</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p>
</blockquote>
<h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><h5 id="🚫-1-违反最左前缀法则（复合索引）"><a href="#🚫-1-违反最左前缀法则（复合索引）" class="headerlink" title="🚫 1. 违反最左前缀法则（复合索引）"></a>🚫 1. 违反最左前缀法则（复合索引）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 复合索引: (last_name, age, city)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span>; <span class="comment">-- 缺少最左列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> city <span class="operator">=</span> <span class="string">&#x27;New York&#x27;</span>; <span class="comment">-- 缺少最左列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Smith&#x27;</span> <span class="keyword">AND</span> city <span class="operator">=</span> <span class="string">&#x27;New York&#x27;</span>; <span class="comment">-- 跳过中间列</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 解决方案</strong>：</p>
<ol>
<li>调整查询条件顺序</li>
<li>创建新索引：<code>CREATE INDEX idx_age_city ON users(age, city)</code></li>
</ol>
<h5 id="🚫-2-在索引列上使用函数或计算"><a href="#🚫-2-在索引列上使用函数或计算" class="headerlink" title="🚫 2. 在索引列上使用函数或计算"></a>🚫 2. 在索引列上使用函数或计算</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引: created_at</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(created_at) <span class="operator">=</span> <span class="number">2023</span>; <span class="comment">-- 函数操作</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">*</span> <span class="number">1.1</span> <span class="operator">&gt;</span> <span class="number">100</span>; <span class="comment">-- 计算操作</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 解决方案</strong>：</p>
<ol>
<li><p>使用范围查询替代：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> created_at <span class="keyword">BETWEEN</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2023-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>预先计算存储：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> products <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> price_with_tax <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">AS</span> (price <span class="operator">*</span> <span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_price_tax <span class="keyword">ON</span> products(price_with_tax);</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="🚫-3-隐式类型转换"><a href="#🚫-3-隐式类型转换" class="headerlink" title="🚫 3. 隐式类型转换"></a>🚫 3. 隐式类型转换</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- phone 是 VARCHAR 索引列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="number">13800138000</span>; <span class="comment">-- 数字 vs 字符串</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 解决方案</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="string">&#x27;13800138000&#x27;</span>; <span class="comment">-- 保持类型一致</span></span><br></pre></td></tr></table></figure>

<h5 id="🚫-4-使用-OR-连接非索引列"><a href="#🚫-4-使用-OR-连接非索引列" class="headerlink" title="🚫 4. 使用 OR 连接非索引列"></a>🚫 4. 使用 <code>OR</code> 连接非索引列</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只有 name 有索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users </span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="keyword">OR</span> email <span class="operator">=</span> <span class="string">&#x27;john@example.com&#x27;</span>; <span class="comment">-- email 无索引</span></span><br></pre></td></tr></table></figure>

<p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会 被用到。</p>
<p><strong>✅ 解决方案</strong>：</p>
<ol>
<li><p>创建联合索引</p>
</li>
<li><p>拆分为两个查询 UNION：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="operator">=</span> <span class="string">&#x27;john@example.com&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="🚫-5-LIKE-以通配符开头"><a href="#🚫-5-LIKE-以通配符开头" class="headerlink" title="🚫 5. LIKE 以通配符开头"></a>🚫 5. <code>LIKE</code> 以通配符开头</h5><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引: email</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;@gmail.com%&#x27;</span>; <span class="comment">-- 后导通配符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;%@gmail.com&#x27;</span>; <span class="comment">-- 前导通配符 索引失效</span></span><br></pre></td></tr></table></figure>

<h5 id="🚫-6-范围查询后的列失效"><a href="#🚫-6-范围查询后的列失效" class="headerlink" title="🚫 6. 范围查询后的列失效"></a>🚫 6. 范围查询后的列失效</h5><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 复合索引: (category, price, rating)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products </span><br><span class="line"><span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;Electronics&#x27;</span> </span><br><span class="line">  <span class="keyword">AND</span> price <span class="operator">&gt;</span> <span class="number">1000</span> </span><br><span class="line">  <span class="keyword">AND</span> rating <span class="operator">&gt;</span> <span class="number">4</span>; <span class="comment">-- rating 无法使用索引</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 解决方案</strong>：</p>
<ol>
<li><p>调整索引列顺序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_category_rating_price <span class="keyword">ON</span> products(category, rating, price); <span class="comment">-- 让等值条件和高选择性范围查询优先使用索引</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用覆盖索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_cover <span class="keyword">ON</span> products(category, price, rating, product_id);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 &gt;&#x3D;：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products </span><br><span class="line"><span class="keyword">WHERE</span> category <span class="operator">=</span> <span class="string">&#x27;Electronics&#x27;</span> </span><br><span class="line">  <span class="keyword">AND</span> price <span class="operator">&gt;=</span> <span class="number">1000</span> </span><br><span class="line">  <span class="keyword">AND</span> rating <span class="operator">&gt;</span> <span class="number">4</span>; <span class="comment">-- 在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt; 。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="🚫-7-使用-或"><a href="#🚫-7-使用-或" class="headerlink" title="🚫 7. 使用 != 或 &lt;&gt;"></a>🚫 7. 使用 <code>!=</code> 或 <code>&lt;&gt;</code></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引: status</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> status <span class="operator">!=</span> <span class="string">&#x27;completed&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>✅ 解决方案</strong>：</p>
<ol>
<li><p>改为范围查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> status <span class="operator">&lt;</span> <span class="string">&#x27;completed&#x27;</span> <span class="keyword">OR</span> status <span class="operator">&gt;</span> <span class="string">&#x27;completed&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用特定值列表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> status <span class="keyword">IN</span> (<span class="string">&#x27;pending&#x27;</span>, <span class="string">&#x27;processing&#x27;</span>, <span class="string">&#x27;cancelled&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="🚫-8-索引列使用-IS-NULL-IS-NOT-NULL"><a href="#🚫-8-索引列使用-IS-NULL-IS-NOT-NULL" class="headerlink" title="🚫 8. 索引列使用 IS NULL&#x2F;IS NOT NULL"></a>🚫 8. 索引列使用 <code>IS NULL</code>&#x2F;<code>IS NOT NULL</code></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引: phone</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>; <span class="comment">-- 可能失效</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 解决方案</strong>：</p>
<ol>
<li><p>添加条件限制：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers </span><br><span class="line"><span class="keyword">WHERE</span> phone <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">AND</span> phone <span class="operator">&gt;</span> <span class="string">&#x27;&#x27;</span>; <span class="comment">-- 利用索引扫描</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用覆盖索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_phone_cover <span class="keyword">ON</span> customers(phone) INCLUDE (name, email);</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="🚫-9-数据分布不均导致优化器放弃索引"><a href="#🚫-9-数据分布不均导致优化器放弃索引" class="headerlink" title="🚫 9. 数据分布不均导致优化器放弃索引"></a>🚫 9. 数据分布不均导致优化器放弃索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引: status (90% 值为 &#x27;active&#x27;)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;active&#x27;</span>; <span class="comment">-- 可能全表扫描</span></span><br></pre></td></tr></table></figure>

<p><strong>✅ 解决方案</strong>：</p>
<ol>
<li><p>强制使用索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products FORCE INDEX(idx_status) </span><br><span class="line"><span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;active&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调整优化器设置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_switch<span class="operator">=</span><span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="🚫-10-使用-NOT-IN"><a href="#🚫-10-使用-NOT-IN" class="headerlink" title="🚫 10. 使用 NOT IN"></a>🚫 10. 使用 <code>NOT IN</code></h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 索引: category</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products </span><br><span class="line"><span class="keyword">WHERE</span> category <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;Books&#x27;</span>, <span class="string">&#x27;Clothing&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>✅ 解决方案</strong>：</p>
<ol>
<li><p>改用 <code>NOT EXISTS</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products p</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> excluded_categories e </span><br><span class="line">  <span class="keyword">WHERE</span> e.category <span class="operator">=</span> p.category</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用左连接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> products p</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> excluded_categories e <span class="keyword">ON</span> p.category <span class="operator">=</span> e.category</span><br><span class="line"><span class="keyword">WHERE</span> e.category <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p>
<ol>
<li>use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。</li>
</ol>
   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ignore index ： 忽略指定的索引。</li>
</ol>
   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>force index ： 强制使用索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</p>
<p>执行计划 <code>EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件</code>  查询结果中 Extra 的含义：</p>
<table>
<thead>
<tr>
<th>Extra</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>Using where; Using Index</td>
<td align="left">查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</td>
</tr>
<tr>
<td>Using index condition</td>
<td align="left">查找使用了索引，但是需要回表查询数据</td>
</tr>
</tbody></table>
<p>为了更清楚理解，什么是覆盖索引，什么是回表查询，我们一起再来看下面的这组SQL的执行过程。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250616235410518.png" alt="image-20250616235410518"></p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250616235424440.png" alt="image-20250616235424440"></p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250616235500388.png" alt="image-20250616235500388"></p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250616235516212.png" alt="image-20250616235516212"></p>
<blockquote>
<p>思考题：</p>
<p>​	一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对以下SQL语句进行优化, 该如何进行才是最优方案?</p>
<p>​	select id,username,password from tb_user where username &#x3D; ‘itcast’</p>
<p>​	答案: </p>
<p>​		针对于 username, password建立联合索引, sql为: create index idx_user_name_pass on tb_user(username,password);</p>
<p>​	这样可以避免上述的SQL语句，在查询的过程中，出现回表查询。</p>
</blockquote>
<h4 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h4><ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引。</li>
<li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li>
<li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增 删改的效率。</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ol>
<h2 id="SQL优化（后面在做）"><a href="#SQL优化（后面在做）" class="headerlink" title="SQL优化（后面在做）"></a>SQL优化（后面在做）</h2><h2 id="视图-存储过程-触发器"><a href="#视图-存储过程-触发器" class="headerlink" title="视图&#x2F;存储过程&#x2F;触发器"></a>视图&#x2F;存储过程&#x2F;触发器</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视 图的查询中使用的表，并且是在使用视图时动态生成的。 通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作 就落在创建这条SQL查询语句上。</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li><p>创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [ <span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> OPTION ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看创建视图语句：<span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br><span class="line">查看视图数据：<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 视图名称 ...... ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方式一：<span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [ <span class="keyword">WITH</span> [ <span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> OPTION ]</span><br><span class="line">方式二：<span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [ <span class="keyword">WITH</span> [ <span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> OPTION ]</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] 视图名称 [,视图名称] ...</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h4><p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插 入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视 图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL ，默认值为 CASCADED 。</p>
<ol>
<li>CASCADED 级联</li>
</ol>
<p>   比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图 创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</p>
<p>   <img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250617141620652.png" alt="image-20250617141620652"></p>
<ol start="2">
<li><p>LOCAL 本地</p>
<p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创 建时未指定检查选项。 则在执行检查时，只会检查v2，不会检查v2的关联视图v1。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250617142456665.png" alt="image-20250617142456665"></p>
</li>
</ol>
<h4 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h4><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一 项，则该视图不可更新：</p>
<ul>
<li><p>聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）</p>
</li>
<li><p>DISTINCT</p>
</li>
<li><p>GROUP BY</p>
</li>
<li><p>HAVING</p>
</li>
<li><p>UNION 或者 UNION ALL</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250617143417946.png" alt="image-20250617143417946"></p>
</li>
</ul>
<h4 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a><strong>视图的作用</strong></h4><ul>
<li>简单：视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</li>
<li>安全：数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。</li>
<li>数据独立：视图可帮助用户屏蔽真实表结构变化带来的影响。</li>
</ul>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发 人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>封装，复用：可以把某一业务SQL封装在存储过程中，需要用到 的时候直接调用即可。</li>
<li>可以接收参数，也可以返回数据：在存储过程中，可以传递参数，也可以接收返回值。</li>
<li>减少网络交互，效率提升：如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</li>
</ul>
<h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li><p>创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([ 参数列表 ])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 名称 ([ 参数 ]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.ROUTINES <span class="keyword">WHERE</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>; <span class="comment">-- 查询指</span></span><br><span class="line">定数据库的存储过程及状态信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ; <span class="comment">-- 查询某个存储过程的定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> [ IF <span class="keyword">EXISTS</span> ] 存储过程名称 ；</span><br></pre></td></tr></table></figure>
</li>
<li><p>案例</p>
<blockquote>
<p>注意: 在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的 结束符。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 存储过程基本语法</span></span><br><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用</span></span><br><span class="line"><span class="keyword">call</span> p1();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.ROUTINES <span class="keyword">where</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;itcast&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> p1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> p1;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。</p>
<ol>
<li><p>系统变量</p>
<p>系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p>
<ul>
<li><p>全局变量(GLOBAL): 全局变量针对于所有的会话。</p>
</li>
<li><p>会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</p>
</li>
<li><p>如果没有指定SESSION&#x2F;GLOBAL，默认是SESSION会话变量。</p>
<blockquote>
<p>mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 &#x2F;etc&#x2F;my.cnf 中配置。</p>
</blockquote>
</li>
</ul>
<p>查看&amp;设置 系统变量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看系统变量</span><br><span class="line"><span class="keyword">SHOW</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] VARIABLES ; <span class="comment">-- 查看所有系统变量</span></span><br><span class="line"><span class="keyword">SHOW</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;......&#x27;</span>; <span class="comment">-- 可以通过LIKE模糊匹配方式查找变量</span></span><br><span class="line"><span class="keyword">SELECT</span> @@[SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>] 系统变量名; <span class="comment">-- 查看指定变量的值</span></span><br><span class="line"></span><br><span class="line"># 设置系统变量</span><br><span class="line"><span class="keyword">SET</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] 系统变量名 <span class="operator">=</span> 值 ;</span><br><span class="line"><span class="keyword">SET</span> @@[SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>]系统变量名 <span class="operator">=</span> 值 ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户定义变量</p>
<p>用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 “@变量 名” 使用就可以。其作用域为当前连接。</p>
<ul>
<li><p>赋值，可以使用 &#x3D; ，也可以使用 :&#x3D; 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方式一:</span><br><span class="line">	<span class="keyword">SET</span> <span class="variable">@var_name</span> <span class="operator">=</span> expr [, <span class="variable">@var_name</span> <span class="operator">=</span> expr] ... ;</span><br><span class="line">	<span class="keyword">SET</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ... ;</span><br><span class="line">方式一:</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="variable">@var_name</span> :<span class="operator">=</span> expr [, <span class="variable">@var_name</span> :<span class="operator">=</span> expr] ... ;</span><br><span class="line">	<span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> <span class="variable">@var_name</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@var_name</span> ;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意: 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p>
</blockquote>
</li>
<li><p>局部变量</p>
<p>局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN … END块。</p>
<ul>
<li><p>声明</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 变量名 变量类型 [<span class="keyword">DEFAULT</span> ... ] ;</span><br><span class="line"><span class="comment">-- 变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> 变量名 <span class="operator">=</span> 值 ;</span><br><span class="line"><span class="keyword">SET</span> 变量名 :<span class="operator">=</span> 值 ;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表名 ... ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 变量名;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>if 用于做条件判断，具体的语法结构为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">IF 条件<span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">.....</span><br><span class="line">ELSEIF 条件<span class="number">2</span> <span class="keyword">THEN</span> <span class="comment">-- 可选</span></span><br><span class="line">.....</span><br><span class="line"><span class="keyword">ELSE</span> <span class="comment">-- 可选</span></span><br><span class="line">.....</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line"># <span class="comment">---------------------举例：根据定义参数score，判定当前分数对应等级--------------------</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> p3;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p3()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> score <span class="type">int</span> <span class="keyword">default</span> <span class="number">58</span>; #声明变量score为<span class="number">58</span>，判断其分数等级</span><br><span class="line">    <span class="keyword">declare</span> grade <span class="type">varchar</span>(<span class="number">10</span>); #用于接收等级</span><br><span class="line">    if score <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> grade :<span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">    elseif score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">set</span> grade :<span class="operator">=</span> <span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">set</span> grade :<span class="operator">=</span> <span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line">    <span class="keyword">select</span> grade;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">call</span> p3; # 不及格</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。</p>
</blockquote>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th align="left">含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td align="left">该类参数作为输入，也就是需要调用时传入值</td>
<td>默认</td>
</tr>
<tr>
<td>OUT</td>
<td align="left">该类参数作为输出，也就是该参数可以作为返回值</td>
<td></td>
</tr>
<tr>
<td>INOUT</td>
<td align="left">既可以作为输入参数，也可以作为输出参数</td>
<td></td>
</tr>
</tbody></table>
<p>用法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([ <span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> 参数名 参数类型 ])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 案例一 根据传入参数score，判定当前分数对应的分数等级，并返回。</span></span><br><span class="line"><span class="comment">-- score &gt;= 85分，等级为优秀。</span></span><br><span class="line"><span class="comment">-- score &gt;= 60分 且 score &lt; 85分，等级为及格。</span></span><br><span class="line"><span class="comment">-- score &lt; 60分，等级为不及格。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> if <span class="keyword">EXISTS</span> p1;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p1(<span class="keyword">IN</span> score <span class="type">INT</span>,<span class="keyword">OUT</span> <span class="keyword">result</span> <span class="type">VARCHAR</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	</span><br><span class="line">	if score <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">THEN</span></span><br><span class="line">		<span class="keyword">SET</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">	ELSEIF score <span class="operator">&gt;</span> <span class="number">60</span> <span class="keyword">THEN</span></span><br><span class="line">		<span class="keyword">SET</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line">	<span class="keyword">ELSE</span> </span><br><span class="line">		<span class="keyword">SET</span> <span class="keyword">result</span> <span class="operator">=</span> <span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line">	<span class="keyword">END</span> if;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明</span></span><br><span class="line"><span class="keyword">call</span> p1(<span class="number">99</span>, <span class="variable">@result</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@result</span>; <span class="comment">-- 优秀</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 案例二 将传入的200分制的分数，进行换算，换算成百分制，然后返回。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> if <span class="keyword">EXISTS</span> p2;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p2(<span class="keyword">INOUT</span> score <span class="keyword">DOUBLE</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">set</span> score :<span class="operator">=</span> score <span class="operator">*</span> <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@score</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">call</span> p2(<span class="variable">@score</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@score</span>; <span class="comment">-- 30</span></span><br></pre></td></tr></table></figure>

<h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p>case结构及作用，和我们在基础篇中所讲解的流程控制函数很类似。有两种语法格式：</p>
<ol>
<li><p>语法1：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，</span></span><br><span class="line">执行statement_list2， 否则就执行 statement_list</span><br><span class="line"><span class="keyword">CASE</span> case_value</span><br><span class="line">	<span class="keyword">WHEN</span> when_value1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">	[ <span class="keyword">WHEN</span> when_value2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">	[ <span class="keyword">ELSE</span> statement_list ]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>语法2：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成</span></span><br><span class="line">立时，执行statement_list2， 否则就执行 statement_list</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line">	<span class="keyword">WHEN</span> search_condition1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">	[<span class="keyword">WHEN</span> search_condition2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">	[<span class="keyword">ELSE</span> statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>案例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 根据传入的月份，判定月份所属的季节（要求采用<span class="keyword">case</span>结构）。</span><br><span class="line"># <span class="number">1</span><span class="number">-3</span>月份，为第一季度</span><br><span class="line"># <span class="number">4</span><span class="number">-6</span>月份，为第二季度</span><br><span class="line"># <span class="number">7</span><span class="number">-9</span>月份，为第三季度</span><br><span class="line"># <span class="number">10</span><span class="number">-12</span>月份，为第四季度</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> if <span class="keyword">EXISTS</span> p3;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p3(<span class="keyword">IN</span> <span class="keyword">month</span> <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> season <span class="type">VARCHAR</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">CASE</span> </span><br><span class="line">		<span class="keyword">WHEN</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">3</span> <span class="keyword">THEN</span></span><br><span class="line">			<span class="keyword">SET</span> season :<span class="operator">=</span> <span class="string">&#x27;第一季度&#x27;</span>;</span><br><span class="line">		<span class="keyword">WHEN</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">4</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">6</span> <span class="keyword">THEN</span></span><br><span class="line">			<span class="keyword">SET</span> season :<span class="operator">=</span> <span class="string">&#x27;第二季度&#x27;</span>;</span><br><span class="line">		<span class="keyword">WHEN</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">7</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">9</span> <span class="keyword">THEN</span></span><br><span class="line">			<span class="keyword">SET</span> season :<span class="operator">=</span> <span class="string">&#x27;第三季度&#x27;</span>;</span><br><span class="line">		<span class="keyword">WHEN</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">12</span> <span class="keyword">THEN</span></span><br><span class="line">			<span class="keyword">SET</span> season :<span class="operator">=</span> <span class="string">&#x27;第四季度&#x27;</span>;</span><br><span class="line">		<span class="keyword">ELSE</span></span><br><span class="line">			<span class="keyword">SET</span> season :<span class="operator">=</span> <span class="string">&#x27;非法参数&#x27;</span>;</span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> concat(<span class="string">&#x27;您输入的月份为: &#x27;</span>,<span class="keyword">month</span>, <span class="string">&#x27;, 所属的季度为: &#x27;</span>,season);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p3(<span class="number">10</span>);# 您输入的月份为: <span class="number">10</span>, 所属的季度为: 第四季度</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。</p>
</blockquote>
<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span></span><br><span class="line">WHILE 条件 DO</span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 计算从<span class="number">1</span>累加到n的值，n为传入的参数值。</span><br><span class="line"><span class="comment">-- A. 定义局部变量, 记录累加之后的值;</span></span><br><span class="line"><span class="comment">-- B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> if <span class="keyword">EXISTS</span> p4;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p4(<span class="keyword">IN</span> num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line">	WHILE num <span class="operator">&gt;</span> <span class="number">0</span> DO</span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="keyword">result</span> <span class="operator">+</span> num;</span><br><span class="line">		<span class="keyword">set</span> num :<span class="operator">=</span> num <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> WHILE;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p4(<span class="number">10</span>); # <span class="number">55</span></span><br></pre></td></tr></table></figure>

<h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p>repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span></span><br><span class="line">REPEAT</span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line">	UNTIL 条件</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 计算从<span class="number">1</span>累加到n的值，n为传入的参数值。(使用repeat实现)</span><br><span class="line"><span class="comment">-- A. 定义局部变量, 记录累加之后的值;</span></span><br><span class="line"><span class="comment">-- B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> if <span class="keyword">EXISTS</span> p5;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p5(<span class="keyword">IN</span> num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line">	REPEAT</span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="keyword">result</span> <span class="operator">+</span> num;</span><br><span class="line">		<span class="keyword">set</span> num :<span class="operator">=</span> num <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">		UNTIL num <span class="operator">&lt;=</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">END</span> REPEAT;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p5(<span class="number">10</span>); # </span><br></pre></td></tr></table></figure>

<h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。 LOOP可以配合一下两个语句使用：</p>
<ul>
<li>LEAVE ：配合循环使用，退出循环。</li>
<li>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] LOOP</span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line"><span class="keyword">END</span> LOOP [end_label];</span><br><span class="line"></span><br><span class="line">LEAVE label; <span class="comment">-- 退出指定标记的循环体</span></span><br><span class="line">ITERATE label; <span class="comment">-- 直接进入下一次循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上述语法中出现的 begin_label，end_label，label 指的都是我们所自定义的标记。</span></span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#  案例一</span><br><span class="line"># 计算从<span class="number">1</span>累加到n的值，n为传入的参数值。</span><br><span class="line"><span class="comment">-- A. 定义局部变量, 记录累加之后的值;</span></span><br><span class="line"><span class="comment">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> if <span class="keyword">EXISTS</span> p6;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p6(<span class="keyword">IN</span> num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> <span class="keyword">result</span> <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line">	getSum: LOOP</span><br><span class="line">		IF num <span class="operator">&lt;=</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">			LEAVE getSum; </span><br><span class="line">		<span class="keyword">END</span> IF; </span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="keyword">result</span> <span class="operator">+</span> num;</span><br><span class="line">		<span class="keyword">set</span> num :<span class="operator">=</span> num <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> LOOP getSum;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p6(<span class="number">10</span>); # <span class="number">55</span></span><br><span class="line"></span><br><span class="line">#  案例二</span><br><span class="line"># 计算从<span class="number">1</span>到n之间的偶数累加的值，n为传入的参数值。</span><br><span class="line"><span class="comment">-- A. 定义局部变量, 记录累加之后的值;</span></span><br><span class="line"><span class="comment">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx</span></span><br><span class="line"><span class="comment">-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. --------&gt; iterate xx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> if <span class="keyword">EXISTS</span> p7;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p7(<span class="keyword">IN</span> num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> <span class="keyword">result</span> <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; </span><br><span class="line">	getSum: LOOP</span><br><span class="line">		IF num <span class="operator">&lt;=</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">			LEAVE getSum; </span><br><span class="line">		<span class="keyword">END</span> IF; </span><br><span class="line">		</span><br><span class="line">		if num<span class="operator">%</span><span class="number">2</span> <span class="operator">=</span> <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> num :<span class="operator">=</span> num <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">			iterate getSum;</span><br><span class="line">		<span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="keyword">result</span> <span class="operator">+</span> num;</span><br><span class="line">		<span class="keyword">set</span> num :<span class="operator">=</span> num <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">END</span> LOOP getSum;</span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p7(<span class="number">10</span>); # <span class="number">30</span></span><br></pre></td></tr></table></figure>

<h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><p>游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 声明游标</span><br><span class="line"><span class="keyword">DECLARE</span> 游标名称 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句 ;</span><br><span class="line"># 打开游标</span><br><span class="line"><span class="keyword">OPEN</span> 游标名称 ;</span><br><span class="line"># 获取游标记录</span><br><span class="line"><span class="keyword">FETCH</span> 游标名称 <span class="keyword">INTO</span> 变量 [, 变量 ] ;</span><br><span class="line"># 关闭游标</span><br><span class="line"><span class="keyword">CLOSE</span> 游标名称 ;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#  根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名</span><br><span class="line">#（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表</span><br><span class="line"># (id,name,profession)中。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 逻辑:</span></span><br><span class="line"><span class="comment">-- A. 声明游标, 存储查询结果集</span></span><br><span class="line"><span class="comment">-- B. 准备: 创建表结构</span></span><br><span class="line"><span class="comment">-- C. 开启游标</span></span><br><span class="line"><span class="comment">-- D. 获取游标中的记录</span></span><br><span class="line"><span class="comment">-- E. 插入数据到新表中</span></span><br><span class="line"><span class="comment">-- F. 关闭游标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> if <span class="keyword">EXISTS</span> p8;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p8(<span class="keyword">IN</span> iage <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	# 有先后顺序：先声明普通变量，再声明游标</span><br><span class="line">	<span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	# <span class="number">1.</span>声明游标 存储查询结果集</span><br><span class="line">	<span class="keyword">DECLARE</span> u_cursor <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> `name`,profession <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> age <span class="operator">&lt;=</span> iage;</span><br><span class="line">	# <span class="number">2.</span>创建新表的 表结构</span><br><span class="line">	<span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">	<span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">		id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line">		name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">		profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">	);</span><br><span class="line">	# <span class="number">3.</span>开启游标</span><br><span class="line">	<span class="keyword">OPEN</span> u_cursor;</span><br><span class="line">	# <span class="number">4.</span>获取游标中的记录</span><br><span class="line">	while <span class="literal">true</span> do</span><br><span class="line">		<span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">		# <span class="number">5.</span>插入数据到新表中</span><br><span class="line">		<span class="keyword">insert into</span> tb_user_pro <span class="keyword">values</span> (<span class="keyword">null</span>, uname, upro);</span><br><span class="line">	<span class="keyword">end</span> while;</span><br><span class="line">	# <span class="number">6.</span>关闭游标</span><br><span class="line">	<span class="keyword">CLOSE</span> u_cursor;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>上述的存储过程，最终我们在调用的过程中，会报错，之所以报错是因为上面的while循环中，并没有 退出条件。当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250618174124701.png" alt="image-20250618174124701"></p>
<p>但是此时，tb_user_pro表结构及其数据都已经插入成功了，我们可以直接刷新表结构，检查表结构中的数据。<br>上述的功能，虽然我们实现了，但是逻辑并不完善，而且程序执行完毕，获取不到数据，数据库还报 错。 接下来，我们就需要来完成这个存储过程，并且解决这个问题。 要想解决这个问题，就需要通过MySQL中提供的条件处理程序 Handler 来解决。</p>
<h4 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h4><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> handler_action HANDLER <span class="keyword">FOR</span> condition_value [, condition_value] ... statement ;</span><br><span class="line">handler_action 的取值：</span><br><span class="line">    CONTINUE: 继续执行当前程序</span><br><span class="line">    EXIT: 终止执行当前程序</span><br><span class="line">condition_value 的取值：</span><br><span class="line">    <span class="keyword">SQLSTATE</span> sqlstate_value: 状态码，如 <span class="number">02000</span></span><br><span class="line">    <span class="keyword">SQLWARNING</span>: 所有以<span class="number">01</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line">    <span class="keyword">NOT</span> FOUND: 所有以<span class="number">02</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line">    <span class="keyword">SQLEXCEPTION</span>: 所有没有被<span class="keyword">SQLWARNING</span> 或 <span class="keyword">NOT</span> FOUND捕获的<span class="keyword">SQLSTATE</span>代码的简写</span><br></pre></td></tr></table></figure>

<p>案例</p>
<ul>
<li><p>通过SQLSTATE指定具体的状态码</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 我们继续来完成在上一小节提出的这个需求，并解决其中的问题。</span><br><span class="line">#  根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名</span><br><span class="line">#（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表</span><br><span class="line"># (id,name,profession)中。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 逻辑:</span></span><br><span class="line"><span class="comment">-- A. 声明游标, 存储查询结果集</span></span><br><span class="line"><span class="comment">-- B. 准备: 创建表结构</span></span><br><span class="line"><span class="comment">-- C. 开启游标</span></span><br><span class="line"><span class="comment">-- D. 获取游标中的记录</span></span><br><span class="line"><span class="comment">-- E. 插入数据到新表中</span></span><br><span class="line"><span class="comment">-- F. 关闭游标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> if <span class="keyword">EXISTS</span> p8;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p8(<span class="keyword">IN</span> iage <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	# 有先后顺序：先声明普通变量，再声明游标</span><br><span class="line">	<span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	# <span class="number">1.</span>声明游标 存储查询结果集</span><br><span class="line">	<span class="keyword">DECLARE</span> u_cursor <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> `name`,profession <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> age <span class="operator">&lt;=</span> iage;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出</span></span><br><span class="line">	<span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br><span class="line">	</span><br><span class="line">	# <span class="number">2.</span>创建新表的 表结构</span><br><span class="line">	<span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">	<span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">		id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line">		name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">		profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">	);</span><br><span class="line">	# <span class="number">3.</span>开启游标</span><br><span class="line">	<span class="keyword">OPEN</span> u_cursor;</span><br><span class="line">	# <span class="number">4.</span>获取游标中的记录</span><br><span class="line">	while <span class="literal">true</span> do</span><br><span class="line">		<span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">		# <span class="number">5.</span>插入数据到新表中</span><br><span class="line">		<span class="keyword">insert into</span> tb_user_pro <span class="keyword">values</span> (<span class="keyword">null</span>, uname, upro);</span><br><span class="line">	<span class="keyword">end</span> while;</span><br><span class="line">	# <span class="number">6.</span>关闭游标</span><br><span class="line">	<span class="keyword">CLOSE</span> u_cursor;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过SQLSTATE的代码简写方式 NOT FOUND。02 开头的状态码，代码简写为 NOT FOUND</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 我们继续来完成在上一小节提出的这个需求，并解决其中的问题。</span><br><span class="line">#  根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名</span><br><span class="line">#（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表</span><br><span class="line"># (id,name,profession)中。</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 逻辑:</span></span><br><span class="line"><span class="comment">-- A. 声明游标, 存储查询结果集</span></span><br><span class="line"><span class="comment">-- B. 准备: 创建表结构</span></span><br><span class="line"><span class="comment">-- C. 开启游标</span></span><br><span class="line"><span class="comment">-- D. 获取游标中的记录</span></span><br><span class="line"><span class="comment">-- E. 插入数据到新表中</span></span><br><span class="line"><span class="comment">-- F. 关闭游标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> if <span class="keyword">EXISTS</span> p8;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> p8(<span class="keyword">IN</span> iage <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	# 有先后顺序：先声明普通变量，再声明游标</span><br><span class="line">	<span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	# <span class="number">1.</span>声明游标 存储查询结果集</span><br><span class="line">	<span class="keyword">DECLARE</span> u_cursor <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> `name`,profession <span class="keyword">FROM</span> tb_user <span class="keyword">WHERE</span> age <span class="operator">&lt;=</span> iage;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02开头时，将关闭游标u_cursor，并退出</span></span><br><span class="line">	<span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">not</span> found <span class="keyword">close</span> u_cursor;</span><br><span class="line">	</span><br><span class="line">	# <span class="number">2.</span>创建新表的 表结构</span><br><span class="line">	<span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">	<span class="keyword">create table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">		id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment,</span><br><span class="line">		name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">		profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">	);</span><br><span class="line">	# <span class="number">3.</span>开启游标</span><br><span class="line">	<span class="keyword">OPEN</span> u_cursor;</span><br><span class="line">	# <span class="number">4.</span>获取游标中的记录</span><br><span class="line">	while <span class="literal">true</span> do</span><br><span class="line">		<span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">		# <span class="number">5.</span>插入数据到新表中</span><br><span class="line">		<span class="keyword">insert into</span> tb_user_pro <span class="keyword">values</span> (<span class="keyword">null</span>, uname, upro);</span><br><span class="line">	<span class="keyword">end</span> while;</span><br><span class="line">	# <span class="number">6.</span>关闭游标</span><br><span class="line">	<span class="keyword">CLOSE</span> u_cursor;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>具体的错误状态码，可以参考官方文档：<br><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html">https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html</a><br><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html</a></p>
</blockquote>
<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 存储函数名称 ([ 参数列表 ])</span><br><span class="line"><span class="keyword">RETURNS</span> type [characteristic ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- SQL语句</span></span><br><span class="line">    <span class="keyword">RETURN</span> ...;</span><br><span class="line"><span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure>

<p>characteristic说明：</p>
<ul>
<li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li>
<li>NO SQL ：不包含 SQL 语句</li>
<li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句</li>
</ul>
<p>案例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 计算从<span class="number">1</span>累加到n的值，n为传入的参数值。</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> fun1 (n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span> <span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">declare</span> sum <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    while n <span class="operator">&gt;</span> <span class="number">0</span> do</span><br><span class="line">        <span class="keyword">set</span> sum :<span class="operator">=</span> sum <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n :<span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"><span class="keyword">END</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> fun1(<span class="number">100</span>); # <span class="number">5050</span></span><br></pre></td></tr></table></figure>

<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。</p>
<p>使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还 只支持行级触发，不支持语句级触发。</p>
<table>
<thead>
<tr>
<th align="left">触发器类型</th>
<th>NEW 和 OLD</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INSERT 型触发器</td>
<td>NEW 表示将要或者已经新增的数据</td>
</tr>
<tr>
<td align="left">UPDATE 型触发器</td>
<td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td align="left">DELETE 型触发器</td>
<td>OLD 表示将要或者已经删除的数据</td>
</tr>
</tbody></table>
<h4 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li><p>创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">BEFORE<span class="operator">/</span>AFTER <span class="keyword">INSERT</span><span class="operator">/</span><span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">ON</span> tbl_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="comment">-- 行级触发器</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	trigger_stmt ;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [schema_name.]trigger_name ; <span class="comment">-- 如果没有指定 schema_name，默认为当前数据库。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>案例</p>
<p>通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加, 修改 , 删除 。</p>
<p>表结构准备:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 准备工作 : 日志表 user_logs</span></span><br><span class="line"><span class="keyword">create table</span> user_logs(</span><br><span class="line">    id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not null</span> auto_increment,</span><br><span class="line">    operation <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span> comment <span class="string">&#x27;操作类型, insert/update/delete&#x27;</span>,</span><br><span class="line">    operate_time datetime <span class="keyword">not null</span> comment <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">    operate_id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not null</span> comment <span class="string">&#x27;操作的ID&#x27;</span>,</span><br><span class="line">    operate_params <span class="type">varchar</span>(<span class="number">500</span>) comment <span class="string">&#x27;操作参数&#x27;</span>,</span><br><span class="line">    <span class="keyword">primary key</span>(`id`)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>插入数据触发器</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建插入触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tb_user_insert_trigger AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> tb_user <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">INSERT INTO</span> user_logs ( id, operation, operate_time, operate_id, operate_params )</span><br><span class="line">	<span class="keyword">VALUES</span></span><br><span class="line">		(<span class="keyword">NULL</span>,<span class="string">&#x27;insert&#x27;</span>,now(),new.id,</span><br><span class="line">		concat(<span class="string">&#x27;插入的数据内容为:id=&#x27;</span>,new.id,<span class="string">&#x27;name=&#x27;</span>,new.NAME,<span class="string">&#x27;, phone=&#x27;</span>,NEW.phone,<span class="string">&#x27;, email=&#x27;</span>,NEW.email,<span class="string">&#x27;,profession=&#x27;</span>,NEW.profession ));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看触发器</span></span><br><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据到tb_user</span></span><br><span class="line"><span class="keyword">insert into</span> tb_user(id, name, phone, email, profession, age, gender, status,createtime) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">26</span>,<span class="string">&#x27;三皇子&#x27;</span>,<span class="string">&#x27;18809091212&#x27;</span>,<span class="string">&#x27;erhuangzi@163.com&#x27;</span>,<span class="string">&#x27;软件工程&#x27;</span>,<span class="number">23</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,now());</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询插入触发器</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_logs;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据触发器</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建更新触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tb_user_update_trigger AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> tb_user <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">INSERT INTO</span> user_logs ( id, operation, operate_time, operate_id, operate_params )</span><br><span class="line">	<span class="keyword">VALUES</span></span><br><span class="line">		(<span class="keyword">NULL</span>,<span class="string">&#x27;update&#x27;</span>,now(),new.id,</span><br><span class="line">		concat(<span class="string">&#x27;更新前的数据内容为:id=&#x27;</span>,old.id,<span class="string">&#x27;name=&#x27;</span>,old.NAME,<span class="string">&#x27;, phone=&#x27;</span>,old.phone,<span class="string">&#x27;, email=&#x27;</span>,old.email,<span class="string">&#x27;,profession=&#x27;</span>,old.profession,</span><br><span class="line">					<span class="string">&#x27;,更新后的数据内容为:id=&#x27;</span>,new.id,<span class="string">&#x27;name=&#x27;</span>,new.NAME,<span class="string">&#x27;, phone=&#x27;</span>,new.phone,<span class="string">&#x27;, email=&#x27;</span>,new.email,<span class="string">&#x27;,profession=&#x27;</span>,new.profession));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看触发器</span></span><br><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新tb_user数据</span></span><br><span class="line"><span class="keyword">update</span> tb_user <span class="keyword">set</span> profession <span class="operator">=</span> <span class="string">&#x27;会计&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询更新触发器</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_logs;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据触发器</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建删除触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tb_user_delete_trigger AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> tb_user <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">INSERT INTO</span> user_logs ( id, operation, operate_time, operate_id, operate_params )</span><br><span class="line">	<span class="keyword">VALUES</span></span><br><span class="line">		(<span class="keyword">NULL</span>,<span class="string">&#x27;delete&#x27;</span>,now(),old.id,</span><br><span class="line">		concat(<span class="string">&#x27;删除的数据内容为:id=&#x27;</span>,old.id,<span class="string">&#x27;name=&#x27;</span>,old.NAME,<span class="string">&#x27;, phone=&#x27;</span>,old.phone,<span class="string">&#x27;, email=&#x27;</span>,old.email,<span class="string">&#x27;,profession=&#x27;</span>,old.profession));</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看触发器</span></span><br><span class="line"><span class="keyword">SHOW</span> TRIGGERS;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除tb_user数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_user <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询删除触发器</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_logs;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、 RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>MySQL中的体系全景图</p>
<pre><code class="highlight mermaid">graph TD
    A[MySQL 锁体系] --&gt; B[按粒度划分]
    A --&gt; C[按功能划分]
    A --&gt; D[按模式划分]
    
    B --&gt; B1[全局锁]
    B --&gt; B2[表级锁]
    B --&gt; B3[行级锁]
    B --&gt; B4[页级锁]
    
    C --&gt; C1[共享锁 S]
    C --&gt; C2[排他锁 X]
    C --&gt; C3[意向共享锁 IS]
    C --&gt; C4[意向排他锁 IX]
    
    D --&gt; D1[悲观锁]
    D --&gt; D2[乐观锁]</code></pre>

<h3 id="共享锁-S-Lock"><a href="#共享锁-S-Lock" class="headerlink" title="共享锁 (S Lock)"></a>共享锁 (S Lock)</h3><p><strong>一个事务已获取共享锁，当另一个事务尝试对具备共享锁的数据进行读操作时，可正常读；进行写操作时，会被共享锁排斥</strong>。</p>
<ul>
<li><p>特性：允许多事务并发读取</p>
</li>
<li><p>兼容性：兼容其他 S 锁，排斥 X 锁</p>
</li>
<li><p>使用场景：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 保证读取期间数据不变</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="comment">-- MySQL8.0之后也优化了写法，如下：</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="排他锁-X-Lock"><a href="#排他锁-X-Lock" class="headerlink" title="排他锁 (X Lock)"></a>排他锁 (X Lock)</h3><p><strong>当一个线程获取到独占锁后，会排斥其他线程（进行读写操作），如若其他线程也想对共享资源&#x2F;同一数据进行操作，必须等到当前线程释放锁并竞争到锁资源才行</strong>。</p>
<ul>
<li><p>特性：独占资源，禁止其他操作</p>
</li>
<li><p>兼容性：排斥所有其他锁</p>
</li>
<li><p>使用场景：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> UPTATE;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="全局锁-Global-Lock"><a href="#全局锁-Global-Lock" class="headerlink" title="全局锁 (Global Lock)"></a>全局锁 (Global Lock)</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p>
<p>典型的使用场景是做全库的逻辑备份。</p>
<ul>
<li>不加全局锁：进行数据备份时，对数据进行DML语句，会导致备份前后数据不一致问题。</li>
<li>加了全局锁：对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。 那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。</li>
</ul>
<h4 id="基本语法-3"><a href="#基本语法-3" class="headerlink" title="基本语法"></a>基本语法</h4><p>加全局锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure>

<p>数据备份</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u username <span class="operator">-</span>p database_name <span class="operator">&gt;</span> backup.sql <span class="comment">-- （备份指定数据库到 backup.sql，执行后输入密码 ）</span></span><br></pre></td></tr></table></figure>

<p>释放全局锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>

<h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p>
<ul>
<li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li>
<li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li>
</ul>
<blockquote>
<p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致 性数据备份。</p>
<p>mysqldump –single-transaction -u username -p database_name &gt; backup.sql</p>
</blockquote>
<h3 id="表级锁-Table-Lock"><a href="#表级锁-Table-Lock" class="headerlink" title="表级锁 (Table Lock)"></a>表级锁 (Table Lock)</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p>
<p>使用表锁的开销相对较小，加锁快，不会产生死锁；但是加锁粒度大，发生锁冲突的概率更高，并发度更低。在innoDB存储引擎中不推荐使用表锁，只有在没有事务支持的存储引擎中才会使用，如MyISAM</p>
<p>对于表级锁，主要分为以下三类：</p>
<ul>
<li>表锁</li>
<li>元数据锁</li>
<li>意向锁</li>
</ul>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>对于表锁，分为两类：</p>
<ul>
<li>表共享读锁（read lock）</li>
<li>表独占写锁（write lock）</li>
</ul>
<h5 id="基本语法-4"><a href="#基本语法-4" class="headerlink" title="基本语法"></a>基本语法</h5><ul>
<li><p>加锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock tables 表名... read<span class="operator">/</span>write。</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables <span class="operator">/</span> 客户端断开连接 。</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h5><ul>
<li><p>读锁：</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619145158965.png" alt="image-20250619145158965"></p>
</li>
<li><p>写锁：</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619145212790.png" alt="image-20250619145212790"></p>
</li>
</ul>
<p>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p>
<h4 id="元数据锁（meta-data-lock-MDL）"><a href="#元数据锁（meta-data-lock-MDL）" class="headerlink" title="元数据锁（meta data lock, MDL）"></a>元数据锁（meta data lock, MDL）</h4><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与 DDL冲突，保证读写的正确性。</p>
<p>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p>
<p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。</p>
<p>常见的SQL操作时，所添加的元数据锁：</p>
<table>
<thead>
<tr>
<th>对应SQL</th>
<th align="left">锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock tables xxx read &#x2F; write（表锁）</td>
<td align="left">SHARED_READ_ONLY &#x2F; SHARED_NO_READ_WRITE</td>
<td></td>
</tr>
<tr>
<td>select 、select … lock in share mode（普通读、共享锁）</td>
<td align="left">SHARED_READ（元数据共享锁）</td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>insert 、update、 delete、select … for update（增、改、删、排他锁）</td>
<td align="left">SHARED_WRITE（元数据共享锁）</td>
<td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td>
</tr>
<tr>
<td>alter table …（修改表结构）</td>
<td align="left">EXCLUSIVE（元数据排他锁）</td>
<td>与其他的MDL都互斥</td>
</tr>
</tbody></table>
<p>案例</p>
<p>当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ &#x2F; SHARED_WRITE），之间是兼容的。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619151806009.png" alt="image-20250619151806009"></p>
<p>当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁 （EXCLUSIVE），之间是互斥的。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619151824887.png" alt="image-20250619151824887"></p>
<p>我们可以通过下面的SQL，来查看数据库中的元数据锁的情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="keyword">from</span> performance_schema.metadata_locks ;</span><br></pre></td></tr></table></figure>

<p>我们在操作过程中，可以通过上述的SQL语句，来查看元数据锁的加锁情况。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619152505379.png" alt="image-20250619152505379"></p>
<h4 id="意向锁（Intention-Lock）"><a href="#意向锁（Intention-Lock）" class="headerlink" title="意向锁（Intention Lock）"></a>意向锁（Intention Lock）</h4><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619153516205.png" alt="image-20250619153516205"></p>
<style>.mopodhhyudfm{zoom: 75%;}</style><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619153533331.png" class="mopodhhyudfm" alt="image-20250619153533331">
<style>.ujwtckhqzlyo{zoom:102%;}</style><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619153742850.png" class="ujwtckhqzlyo" alt="image-20250619153742850">

<p>分类</p>
<ul>
<li>意向共享锁（IS）：由语句select … lock in share mode添加，与表锁共享锁（read）兼容，与表锁排他锁（write）互斥。在准备给表数据添加一个S锁时，需要先获得该表的IS锁</li>
<li>意向排他锁（IX）：由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。在准备给表数据添加一个X锁时，需要先获得该表的IX锁</li>
</ul>
<blockquote>
<p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p>
</blockquote>
<p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure>

<p>案例</p>
<p>A.意向共享锁与表读锁是兼容的</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619155204018.png" alt="image-20250619155204018"></p>
<p>B.意向排他锁与表读锁、写锁都是互斥的</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619155225203.png" alt="image-20250619155225203"></p>
<p><strong>兼容矩阵</strong>：</p>
<table>
<thead>
<tr>
<th align="left">请求\持有</th>
<th align="left">X</th>
<th align="left">IX</th>
<th align="left">S</th>
<th align="left">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>X（共享锁）</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
</tr>
<tr>
<td align="left"><strong>IX（意向排他锁）</strong></td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">✅</td>
</tr>
<tr>
<td align="left"><strong>S（排他锁）</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">✅</td>
</tr>
<tr>
<td align="left"><strong>IS（意向共享锁）</strong></td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">✅</td>
</tr>
</tbody></table>
<h3 id="行级锁-Row-Lock"><a href="#行级锁-Row-Lock" class="headerlink" title="行级锁 (Row Lock)"></a>行级锁 (Row Lock)</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB存储引擎中。InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p>
<ul>
<li><p>行锁（Record Lock）</p>
</li>
<li><p>间隙锁（Gap Lock）</p>
</li>
<li><p>临键锁（Next-Key Lock）</p>
</li>
</ul>
<h4 id="行锁-记录锁（Record-Lock）"><a href="#行锁-记录锁（Record-Lock）" class="headerlink" title="行锁 &#x2F; 记录锁（Record Lock）"></a>行锁 &#x2F; 记录锁（Record Lock）</h4><p>锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619161449148.png" alt="image-20250619161449148"></p>
<p>InnoDB实现了以下两种类型的行锁：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li>
<li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</li>
</ul>
<p>两种行锁的兼容情况如下:</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619162711773.png" alt="image-20250619162711773"></p>
<p>常见的SQL语句，在执行时，所加的行锁如下：</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619162729583.png" alt="image-20250619162729583"></p>
<p>案例</p>
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p>
<ul>
<li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li>
<li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</li>
</ul>
<p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure>

<h4 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h4><p>锁定索引记录间隙（不含该记录），左右开区间，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619161503768.png" alt="image-20250619161503768"></p>
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p>
<p><strong>加间隙锁的规则</strong></p>
<ul>
<li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li>
<li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</li>
<li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li>
</ul>
<blockquote>
<p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>
</blockquote>
<h4 id="临键锁（Next-Key-Lock）"><a href="#临键锁（Next-Key-Lock）" class="headerlink" title="临键锁（Next-Key Lock）"></a>临键锁（Next-Key Lock）</h4><p>行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap，左开右闭。 在RR隔离级别下支持。</p>
<p> <img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250619161513760.png" alt="image-20250619161513760"></p>
<p>案例</p>
<p>A. 索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 </p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250620103800893.png" alt="image-20250620103800893"></p>
<p>B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。 </p>
<p>分析： InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也 就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250620142439702.png" alt="image-20250620142439702"></p>
<p>C. 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250620143630717.png" alt="image-20250620143630717"></p>
<p>查询的条件为id&gt;&#x3D;19，并添加共享锁。此时我们可以根据数据库表中现有的数据，将数据分为三个部分： [19] (19,25] (25,+∞] 所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临键锁(正无穷及之前的间隙)。</p>
<h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h3><h4 id="悲观锁（Pessimistic-Locking）"><a href="#悲观锁（Pessimistic-Locking）" class="headerlink" title="悲观锁（Pessimistic Locking）"></a>悲观锁（Pessimistic Locking）</h4><ul>
<li><strong>假设冲突必然发生</strong>，因此在访问数据前先加锁，阻止其他事务同时修改。</li>
<li><strong>适用场景</strong>：写操作频繁、并发冲突概率高的场景（如库存扣减、金融转账）。</li>
</ul>
<p><strong>实现方式</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 行级锁</span></span><br><span class="line"><span class="comment">-- 共享锁（S锁）：允许多事务同时读</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 排他锁（X锁）：阻止其他事务读写</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表级锁</span></span><br><span class="line">LOCK TABLES products WRITE;  <span class="comment">-- 写锁（排他）</span></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：确保数据一致性，避免脏写。</li>
<li>缺点：<ul>
<li>增加锁等待时间，降低并发性能。</li>
<li>可能导致死锁（如事务循环等待锁）。</li>
</ul>
</li>
</ul>
<h4 id="乐观锁（Optimistic-Locking）"><a href="#乐观锁（Optimistic-Locking）" class="headerlink" title="乐观锁（Optimistic Locking）"></a>乐观锁（Optimistic Locking）</h4><ul>
<li><strong>假设冲突很少发生</strong>，不提前加锁，而是在提交时检查数据是否被修改。</li>
<li><strong>适用场景</strong>：读操作频繁、冲突概率低的场景（如商品浏览量统计）。</li>
</ul>
<p><strong>实现方式</strong>：</p>
<ul>
<li><p><strong>版本号（Version）</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表结构增加 version 字段</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> products (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  stock <span class="type">INT</span>,</span><br><span class="line">  version <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务1：读取数据</span></span><br><span class="line"><span class="keyword">SELECT</span> stock, version <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务1：更新时校验 version</span></span><br><span class="line"><span class="keyword">UPDATE</span> products </span><br><span class="line"><span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span>, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> version <span class="operator">=</span> 上次读取的version;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>时间戳（Timestamp）</strong>：类似版本号，使用时间戳字段记录数据修改时间。</p>
</li>
<li><p>优点：</p>
<ul>
<li>无需加锁，提升并发性能。</li>
<li>避免死锁。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>需要应用层处理冲突（如重试机制）。</li>
<li>不适合高冲突场景（重试频繁会降低效率）。</li>
</ul>
</li>
</ul>
<h2 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h2><h3 id="InnoDB的逻辑存储结构"><a href="#InnoDB的逻辑存储结构" class="headerlink" title="InnoDB的逻辑存储结构"></a>InnoDB的逻辑存储结构</h3><p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250620104752975.png" alt="image-20250620104752975"></p>
<ol>
<li><p>表空间</p>
<p>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在 8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p>
</li>
<li><p>段</p>
<p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段 （Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的 非叶子节点。段用来管理多个Extent（区）。</p>
</li>
<li><p>区</p>
<p>区，表空间的单元结构，每个区的大小为1M。 默认情况下，InnoDB存储引擎页大小为16K， 即一 个区中一共有64个连续的页。</p>
</li>
<li><p>页</p>
<p>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p>
</li>
<li><p>行</p>
<p>行，InnoDB 存储引擎数据是按行进行存放的。 </p>
<p>在行中，默认有两个隐藏字段：</p>
<ul>
<li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li>
<li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
</li>
</ol>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250620105415790.png" alt="image-20250620105415790"></p>
<h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 接下来介绍一下这四个部分。</p>
<ol>
<li><p>Buffer Pool</p>
<p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I&#x2F;O。</p>
<p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及 InnoDB的锁信息等等。</p>
<p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增、删、改、查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p>
<p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p>
<ul>
<li>free page：空闲page，未被使用</li>
<li>clean page：被使用page，数据没有被修改过</li>
<li>dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致</li>
</ul>
<blockquote>
<p>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置： show variables like ‘innodb_buffer_pool_size’;</p>
</blockquote>
</li>
<li><p>Change Buffer</p>
<p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page 没有在Buffer Pool中，是不会直接操作磁盘，而是会将数据变更存在更改缓冲区 Change Buffer 中，在以后数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p>
<p>意义：与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了 ChangeBuffer 之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p>
</li>
<li><p>Adaptive Hash Index</p>
</li>
</ol>
<p>   自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持 hash索引，但是给我们提供了一个功能就是这个自适应hash索引。hash索引在 进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。</p>
<p>   InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度， 则建立hash索引，称之为自适应hash索引。<strong>自适应哈希索引，无需人工干预，是系统根据情况自动完成。</strong></p>
   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数： adaptive_hash_index</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>Log Buffer</p>
<p>日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log）， 默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。</p>
<p>参数</p>
<ul>
<li>innodb_log_buffer_size：缓冲区大小</li>
<li>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：<ul>
<li>1：日志在每次事务提交时写入并刷新到磁盘，默认值</li>
<li>0: 每秒将日志写入并刷新到磁盘一次</li>
<li>2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250620123258462.png" alt="image-20250620123258462"></p>
<ol>
<li><p>System Tablespace</p>
<p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)。参数：innodb_data_file_path。系统表空间，默认的文件名叫 ibdata1。</p>
</li>
<li><p><strong>File-Per-Table Tablespaces</strong></p>
<p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索 引 ，并存储在文件系统上的单个数据文件中。 开关参数：innodb_file_per_table ，该参数默认开启。我们每创建一个表，都会产生一个表空间文件（.ibd）。</p>
</li>
<li><p>General Tablespaces</p>
</li>
</ol>
<p>   通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p>
<ul>
<li><p>创建表空间</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TABLESPACE ts_name <span class="keyword">ADD</span> DATAFILE <span class="string">&#x27;file_name&#x27;</span> ENGINE <span class="operator">=</span> engine_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建表时指定表空间</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> xxx ... TABLESPACE ts_name;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><p>Undo Tablespaces</p>
<p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储 undo log日志。</p>
</li>
<li><p>Temporary Tablespaces</p>
<p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p>
</li>
<li><p>Doublewrite Buffer Files</p>
<p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件 中，便于系统异常时恢复数据。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250620160119189.png" alt="image-20250620160119189"></p>
</li>
<li><p>Redo Log</p>
<p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。以循环方式写入重做日志文件，涉及两个文件：</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250620161720172.png" alt="image-20250620161720172"></p>
</li>
</ol>
<h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>在Innodb存储引擎中，后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。此外它会将已经修改的数据文件刷新到磁盘文件中，保证在不发生异常的情况下，Innodb能够恢复到正常的运行状态。</p>
<style>.mmvmuykeitnf{zoom:80%;}</style><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250620164920302.png" class="mmvmuykeitnf" alt="image-20250620164920302">

<h5 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h5><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性， 还包括脏页的刷新、合并插入缓存、undo页的回收 。</p>
<h5 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h5><p>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。</p>
<table>
<thead>
<tr>
<th>线程类型</th>
<th align="left">默认个数</th>
<th align="left">职责</th>
</tr>
</thead>
<tbody><tr>
<td>Read thread</td>
<td align="left">4</td>
<td align="left">负责读操作</td>
</tr>
<tr>
<td>Write thread</td>
<td align="left">4</td>
<td align="left">负责写操作</td>
</tr>
<tr>
<td>Log thread</td>
<td align="left">1</td>
<td align="left">负责将日志缓冲区刷新到磁盘</td>
</tr>
<tr>
<td>Insert buffer thread</td>
<td align="left">1</td>
<td align="left">负责将写缓冲区内容刷新到磁盘</td>
</tr>
</tbody></table>
<p>我们可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engine innodb status \G;</span><br></pre></td></tr></table></figure>

<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250620165736769.png" alt="image-20250620165736769"></p>
<h5 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h5><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p>
<h5 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h5><p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p>
<h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><p>事务：是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p>事务特性：</p>
<ul>
<li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </li>
<li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li>
<li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250621224123076.png" alt="image-20250621224123076"></p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250620171117621.png" alt="image-20250620171117621"></p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p>
<p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中,用于在刷新脏页到磁盘,发生错误时,进行数据恢复使用。</p>
<ul>
<li><p>没有redo log，可能会存在什么问题</p>
<ul>
<li><p>在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 </p>
</li>
<li><p>当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中。</p>
</li>
<li><p>然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。</p>
</li>
<li><p>脏页会在一定的时机，通过后台线程将缓冲区的数据刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 </p>
</li>
<li><p>但是缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250621225711788.png" alt="image-20250621225711788"></p>
</li>
</ul>
</li>
<li><p>InnoDB中提供了一份日志 redo log</p>
<ul>
<li><p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。</p>
</li>
<li><p>在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。</p>
</li>
<li><p>过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。</p>
</li>
<li><p>而如果脏页成功刷新到磁盘或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p>
<blockquote>
<p>为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?</p>
<p>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据时，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 <strong>WAL（Write-Ahead Logging）</strong>。</p>
</blockquote>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250621230200290.png" alt="image-20250621230200290"></p>
</li>
</ul>
</li>
</ul>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。</p>
<p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的 update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p>
<ul>
<li>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</li>
<li>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li>
</ul>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><strong>MVCC</strong></h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ol>
<li><p>当前读</p>
<p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。</p>
<p>案例</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250621231422373.png" alt="image-20250621231422373"></p>
<ul>
<li>上面案例中当前隔离级别是RC（可重复读）中，同时开启两个事务。在事务A中，使用普通select 查询语句无法查询事务B中修改的数据。</li>
<li>但是在查询语句后面加上了 <code>lock in share mode</code> 共享锁，此时是当前读操作。当然，我们加排他锁的时候，也是当前读操作。可以读取到事务B最新提交的内容。</li>
</ul>
</li>
<li><p>快照读</p>
<p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p>
<ul>
<li>Read Committed 读已提交：每次select，都生成一个快照读</li>
<li>Repeatable Read 可重复高读：开启事务后第一个select语句才是快照读的地方。即第一次select查询产生快照读，后面的select查询直接使用前面的快照数据</li>
<li>Serializable 串行化：快照读会退化为当前读，每次读取都需要加锁</li>
</ul>
<p>案例</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250621231957468.png" alt="image-20250621231957468"></p>
<p>在测试中,我们看到即使事务B提交了数据,事务A中也查询不到。原因就是因为普通的select是快照读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p>
</li>
<li><p><strong>MVCC</strong></p>
</li>
</ol>
<p>   全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p>
<h5 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h5><p>当我们创建表的时候，除了我们自己定义的字段以为，InnoDB还会自动的给我们添加三个隐藏字段。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250621232531157.png" alt="image-20250621232531157"></p>
<blockquote>
<p> 前两个字段是肯定会添加的，是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p>
</blockquote>
<h5 id="undo-log-1"><a href="#undo-log-1" class="headerlink" title="undo log"></a>undo log</h5><ul>
<li>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</li>
<li>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</li>
<li>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</li>
</ul>
<p>undo log 版本链</p>
<p>演示：如果四个事务需要同时访问同一条记录时。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250621233632797.png" alt="image-20250621233632797"></p>
<blockquote>
<p>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。 DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p>
</blockquote>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250621234515153.png" alt="image-20250621234515153"></p>
<blockquote>
<p><strong>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条 记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</strong></p>
</blockquote>
<h5 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h5><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250621235043848.png" alt="image-20250621235043848"></p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250621235208265.png" alt="image-20250621235208265"></p>
<p><strong>不同的隔离级别，生成ReadView的时机不同：</strong> </p>
<ul>
<li>READ COMMITTED：在事务中每一次执行快照读时生成ReadView。 </li>
<li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li>
</ul>
<h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><ul>
<li><p>RC隔离级别</p>
<p><strong>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</strong></p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/0ed1156035e50af2c60e93e066b67b5.png" alt="0ed1156035e50af2c60e93e066b67b5"></p>
<p>分析：</p>
<ol>
<li>将左下记录根据 DB_TRX_ID （当前事务id  为4）带入右下版本链规则 ①②③④ 中，发现都不成立。说明本次快照读查找的数据不是事务id为4的记录。</li>
<li>按照版本链往下找（根据表尾地址查找）下一条记录，找到事务id为3的记录，在 ①②③④ 都不成立，继续向下寻找。</li>
<li>找到一条事务id为2的记录，发现②成立。说明本次快照读查找的数据&#x3D;是事务id为2的记录。</li>
</ol>
</li>
<li><p>RR隔离级别</p>
<p><strong>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</strong>。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250622222312347.png" alt="image-20250622222312347"></p>
<p>在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该 ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。</p>
</li>
</ul>
<p>结论：MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。 而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p>
<p><img src="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/image-20250622222613229.png" alt="image-20250622222613229"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://pybuzs.github.io">bbiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://pybuzs.github.io/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/">https://pybuzs.github.io/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://pybuzs.github.io" target="_blank">片叶不沾身的花园</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySql%E8%BF%9B%E9%98%B6-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">MySql进阶 学习笔记</a></div><div class="post-share"><div class="social-share" data-image="/image/touxiang.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/23/Interview/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/" title="MySQL面试题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">MySQL面试题</div></div><div class="info-2"><div class="info-item-1">MySQL面试题 此笔记为本人备考面试时整理，内容多源于网络搜集，仅作后续查阅之用，无盈利意图。若有侵权，请联系删除。 参考资料： https://javaguide.cn/ https://www.xiaolincoding.com/ https://pdai.tech https://javabetter.cn/  一、MySQL基础1、数据库三大范式查看答案 1NF 要求字段值必须是不可再分的原子值。 反例：用户信息表中地址字段存储 “北京市海淀区”，未拆分为省、市、区，违反 1NF；正例：拆分为province、city、district，每个字段独立存储。  2NF 1NF的基础上，要求非主属性完全依赖主键，避免部分依赖（如订单明细拆分）。 场景：订单明细表（（订单号+商品ID为主键）+ 金额 ），若字段订单金额仅依赖订单号，则存在部分依赖（非主属性订单金额不依赖商品ID），违反 2NF；优化：拆分为订单表（订单号、金额）和订单明细表（订单号、商品 ID、数量）。  3NF 2NF的基础上，非主键字段之间不能有依赖关系，消除传递依赖，如学生表与班级表分离。 反例：学生表...</div></div></div></a><a class="pagination-related" href="/2025/06/04/RandomNotes/%E7%B3%BB%E7%BB%9F%E5%8D%87%E7%BA%A7/" title="系统升级"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">系统升级</div></div><div class="info-2"><div class="info-item-1">SSH框架升级为SpringBoot前言和准备 公司系统使用框架为SSH（Spring + Spring MVC + Hibernate)，现在要求升级为SpringBoot。   原项目：Spring 3.1.3 + Hibernate 4.2.21 使用jar包方式   准备升级为：SpringBoot2.7.6 +  使用mavne管理jar包 Spring Boot 2.x需要Spring 5和Hibernate 5.2+，因此我们需要升级这些依赖。  步骤1. 创建Spring Boot项目   使用阿里云地址 https://start.aliyun.com/ 来创建一个新的Spring Boot 项目。选择 JDK8、Maven、Spring Boot 版本2.7.6。    目录结构为：     2. jar包用maven替换将原项目src下的目录复制到新建的项目中。先运行一下@SpringBootApplication 类，根据报错去添加相关依赖。没有去网站[Maven Repository: Search/Browse/Explore (mvnreposito...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">bbiao</div><div class="author-info-description">不要假装努力，结果不会陪你演戏</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" href="https://pybuzs.github.io/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySql%E8%BF%9B%E9%98%B6"><span class="toc-number">1.</span> <span class="toc-text">MySql进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">MySQL体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.2.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB"><span class="toc-number">1.2.1.</span> <span class="toc-text">InnoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">文件结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">逻辑存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyISAM"><span class="toc-number">1.2.2.</span> <span class="toc-text">MyISAM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-1"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">文件结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory"><span class="toc-number">1.2.3.</span> <span class="toc-text">Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-2"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">文件结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB-MyISAM-Memory%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.4.</span> <span class="toc-text">InnoDB, MyISAM, Memory的区别，使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">1.3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-number">1.3.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.3.</span> <span class="toc-text">索引结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Tree"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">B-Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Tree-1"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">B+Tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">Hash</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">回表查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">思考题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95"><span class="toc-number">1.3.5.</span> <span class="toc-text">索引语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.3.6.</span> <span class="toc-text">SQL性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E6%89%A7%E8%A1%8C%E9%A2%91%E7%8E%87"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">SQL执行频率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">慢查询日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#profile%E8%AF%A6%E6%83%85"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">profile详情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explain"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">explain</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.7.</span> <span class="toc-text">索引使用优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">单列索引与联合索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">前缀索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-number">1.3.7.3.</span> <span class="toc-text">最左前缀法则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%A7%A9-%E5%9B%9B%E7%A7%8D%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.3.7.3.1.</span> <span class="toc-text">🧩 四种典型使用场景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-1%EF%BC%9A%E5%AE%8C%E6%95%B4%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95-%E6%9C%80%E4%BD%B3"><span class="toc-number">1.3.7.3.1.1.</span> <span class="toc-text">✅ 场景 1：完整使用索引 (最佳)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-2%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B7%A6%E8%BF%9E%E7%BB%AD%E5%88%97"><span class="toc-number">1.3.7.3.1.2.</span> <span class="toc-text">✅ 场景 2：使用最左连续列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-3%EF%BC%9A%E4%BB%85%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B7%A6%E5%88%97"><span class="toc-number">1.3.7.3.1.3.</span> <span class="toc-text">✅ 场景 3：仅使用最左列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%9D%8C-%E5%9C%BA%E6%99%AF-4%EF%BC%9A%E8%BF%9D%E5%8F%8D%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%EF%BC%88%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%EF%BC%89"><span class="toc-number">1.3.7.3.1.4.</span> <span class="toc-text">❌ 场景 4：违反最左前缀（常见错误）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-5%EF%BC%9A%E6%9D%A1%E4%BB%B6%E7%BC%96%E5%86%99%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.3.7.3.1.5.</span> <span class="toc-text">✅ 场景 5：条件编写的先后顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5"><span class="toc-number">1.3.7.4.</span> <span class="toc-text">索引失效情况</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%9A%AB-1-%E8%BF%9D%E5%8F%8D%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99%EF%BC%88%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">1.3.7.4.1.</span> <span class="toc-text">🚫 1. 违反最左前缀法则（复合索引）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%9A%AB-2-%E5%9C%A8%E7%B4%A2%E5%BC%95%E5%88%97%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%88%96%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.7.4.2.</span> <span class="toc-text">🚫 2. 在索引列上使用函数或计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%9A%AB-3-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.7.4.3.</span> <span class="toc-text">🚫 3. 隐式类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%9A%AB-4-%E4%BD%BF%E7%94%A8-OR-%E8%BF%9E%E6%8E%A5%E9%9D%9E%E7%B4%A2%E5%BC%95%E5%88%97"><span class="toc-number">1.3.7.4.4.</span> <span class="toc-text">🚫 4. 使用 OR 连接非索引列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%9A%AB-5-LIKE-%E4%BB%A5%E9%80%9A%E9%85%8D%E7%AC%A6%E5%BC%80%E5%A4%B4"><span class="toc-number">1.3.7.4.5.</span> <span class="toc-text">🚫 5. LIKE 以通配符开头</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%9A%AB-6-%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E5%88%97%E5%A4%B1%E6%95%88"><span class="toc-number">1.3.7.4.6.</span> <span class="toc-text">🚫 6. 范围查询后的列失效</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%9A%AB-7-%E4%BD%BF%E7%94%A8-%E6%88%96"><span class="toc-number">1.3.7.4.7.</span> <span class="toc-text">🚫 7. 使用 !&#x3D; 或 &lt;&gt;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%9A%AB-8-%E7%B4%A2%E5%BC%95%E5%88%97%E4%BD%BF%E7%94%A8-IS-NULL-IS-NOT-NULL"><span class="toc-number">1.3.7.4.8.</span> <span class="toc-text">🚫 8. 索引列使用 IS NULL&#x2F;IS NOT NULL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%9A%AB-9-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E4%B8%8D%E5%9D%87%E5%AF%BC%E8%87%B4%E4%BC%98%E5%8C%96%E5%99%A8%E6%94%BE%E5%BC%83%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.7.4.9.</span> <span class="toc-text">🚫 9. 数据分布不均导致优化器放弃索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%F0%9F%9A%AB-10-%E4%BD%BF%E7%94%A8-NOT-IN"><span class="toc-number">1.3.7.4.10.</span> <span class="toc-text">🚫 10. 使用 NOT IN</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E6%8F%90%E7%A4%BA"><span class="toc-number">1.3.7.5.</span> <span class="toc-text">SQL提示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.7.6.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.3.7.7.</span> <span class="toc-text">索引设计原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96%EF%BC%88%E5%90%8E%E9%9D%A2%E5%9C%A8%E5%81%9A%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">SQL优化（后面在做）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">视图&#x2F;存储过程&#x2F;触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">1.5.1.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E9%80%89%E9%A1%B9"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">检查选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">视图的更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">视图的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#if"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">case</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while"><span class="toc-number">1.5.2.7.</span> <span class="toc-text">while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repeat"><span class="toc-number">1.5.2.8.</span> <span class="toc-text">repeat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#loop"><span class="toc-number">1.5.2.9.</span> <span class="toc-text">loop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87"><span class="toc-number">1.5.2.10.</span> <span class="toc-text">游标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.2.11.</span> <span class="toc-text">条件处理程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.3.</span> <span class="toc-text">存储函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">基本语法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.6.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81-S-Lock"><span class="toc-number">1.6.1.</span> <span class="toc-text">共享锁 (S Lock)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E4%BB%96%E9%94%81-X-Lock"><span class="toc-number">1.6.2.</span> <span class="toc-text">排他锁 (X Lock)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81-Global-Lock"><span class="toc-number">1.6.3.</span> <span class="toc-text">全局锁 (Global Lock)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-3"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-5"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81-Table-Lock"><span class="toc-number">1.6.4.</span> <span class="toc-text">表级锁 (Table Lock)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">表锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-4"><span class="toc-number">1.6.4.1.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-6"><span class="toc-number">1.6.4.1.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%EF%BC%88meta-data-lock-MDL%EF%BC%89"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">元数据锁（meta data lock, MDL）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88Intention-Lock%EF%BC%89"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">意向锁（Intention Lock）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81-Row-Lock"><span class="toc-number">1.6.5.</span> <span class="toc-text">行级锁 (Row Lock)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E9%94%81-%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%88Record-Lock%EF%BC%89"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">行锁 &#x2F; 记录锁（Record Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Lock%EF%BC%89"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">间隙锁（Gap Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%88Next-Key-Lock%EF%BC%89"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">临键锁（Next-Key Lock）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">1.6.6.</span> <span class="toc-text">乐观锁&#x2F;悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%88Pessimistic-Locking%EF%BC%89"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">悲观锁（Pessimistic Locking）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%88Optimistic-Locking%EF%BC%89"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">乐观锁（Optimistic Locking）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%BC%95%E6%93%8E"><span class="toc-number">1.7.</span> <span class="toc-text">InnoDB引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E7%9A%84%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.1.</span> <span class="toc-text">InnoDB的逻辑存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">1.7.2.</span> <span class="toc-text">架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">内存结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">磁盘结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">后台线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Master-Thread"><span class="toc-number">1.7.2.3.1.</span> <span class="toc-text">Master Thread</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IO-Thread"><span class="toc-number">1.7.2.3.2.</span> <span class="toc-text">IO Thread</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Purge-Thread"><span class="toc-number">1.7.2.3.3.</span> <span class="toc-text">Purge Thread</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Page-Cleaner-Thread"><span class="toc-number">1.7.2.3.4.</span> <span class="toc-text">Page Cleaner Thread</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.3.</span> <span class="toc-text">事务原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MVCC"><span class="toc-number">1.7.3.3.</span> <span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.3.3.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="toc-number">1.7.3.3.2.</span> <span class="toc-text">隐藏字段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#undo-log-1"><span class="toc-number">1.7.3.3.3.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#readview"><span class="toc-number">1.7.3.3.4.</span> <span class="toc-text">readview</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">1.7.3.3.5.</span> <span class="toc-text">原理分析</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/23/RandomNotes/windows%E5%90%8C%E6%97%B6%E5%AE%89%E8%A3%85%E4%B8%A4%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84Mysql/" title="windows同时安装两个不同版本的Mysql">windows同时安装两个不同版本的Mysql</a><time datetime="2025-06-23T02:47:57.000Z" title="发表于 2025-06-23 10:47:57">2025-06-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/23/Interview/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/" title="MySQL面试题">MySQL面试题</a><time datetime="2025-06-23T01:46:59.000Z" title="发表于 2025-06-23 09:46:59">2025-06-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/10/MySQL/MySql%E8%BF%9B%E9%98%B6/" title="MySql进阶">MySql进阶</a><time datetime="2025-06-10T03:31:31.000Z" title="发表于 2025-06-10 11:31:31">2025-06-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/RandomNotes/%E7%B3%BB%E7%BB%9F%E5%8D%87%E7%BA%A7/" title="系统升级">系统升级</a><time datetime="2025-06-04T07:54:03.000Z" title="发表于 2025-06-04 15:54:03">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/25/Java/JVM/JVM%20%E5%9F%BA%E7%A1%80%205%20-%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="JVM 基础 5 - GC 垃圾回收">JVM 基础 5 - GC 垃圾回收</a><time datetime="2025-05-25T08:39:33.000Z" title="发表于 2025-05-25 16:39:33">2025-05-25</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By bbiao</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="/styles/fish.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>